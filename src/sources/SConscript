import time, sys, os, shutil

#############################################################
#                    SUPPORT FUNCTIONS                      #
#############################################################
def getNativelySupportedArchs():
  natArchs = ['generic']
  x86ArchMachines = ['i386', 'i486', 'i586', 'i686', 'x86_64']
  currentPlatformMachine = platform.machine()

  
  if currentPlatformMachine in x86ArchMachines:
    natArchs.append('x86')
    if currentPlatformMachine == 'x86_64':
      natArchs.append('x86_64')
  elif currentPlatformMachine == 'Power Macintosh':
    natArchs.append('ppc')

  return tuple(natArchs)




Import('env')

env.Append( CPPPATH=['#/src/sources/nucleo'] )

files = Split("""
    CRT.cpp
    Factor.cpp
    Funciones.cpp
    GCD.cpp
    Hash.cpp
    LCM.cpp
    mp.cpp
    Potencia.cpp
    Primos.cpp
    Random.cpp
    R.cpp
    RedModular.cpp
    Semillero.cpp
    SimbolosLegendre.cpp
    Trascendentes.cpp
    Z.cpp
    Z_n.cpp
    VectorZ.cpp
    MatrixZ.cpp
    """)

env.Append(CCFLAGS = ' -pipe ')
env.Append(CCFLAGS = ' -O' + env['optLevel'])

  
try:
  import platform

  if env['arch'] not in getNativelySupportedArchs():
    print "\nWARNING: the selected architecture (" + env['arch'] + ") is not natively supported by this system"
    for i in xrange(3):
      time.sleep(1)
      print '.',
      sys.stdout.flush()
    else:
      print ''
  env['SYSTEMBITS'] = platform.architecture()[0][:2]

except ImportError:
  print "Platform support checking not supported by the Python installed: " + sys.version
  env['SYSTEMBITS'] = "32"

if env['enableProf']:
  env['arch'] += 'Prof'
env.Append(CPPDEFINES = [('ARCH', env['arch'])])

if env['arch'][:6] == 'x86_64':
  env.Append(CPPDEFINES = [('ARCHBITS', '64')])
else:
  env.Append(CPPDEFINES = [('ARCHBITS', '32')])


if env['enableRelease']:
  env.Append(CPPDEFINES = ['RELEASE','NDEBUG'])
 

#if env['enableExtraOpt']: 
#  env.Append(CCFLAGS = ' -ffast-math')  #FIXME: esto con icc no chuta

if env['enableDebug']:
  env.Append(CCFLAGS = ' -g')

if env['enableWarnings']:
  env.Append(CCFLAGS = ' -Wall -W')
#options processing ends

def CheckOpenMP(context):
  context.Message('Checking for OpenMP support... ')
  ret = context.TryRun( 
    """
      #include <omp.h>
      int main(){
        #ifdef _OPENMP
          return 0;
        #else
          return 1;
        #endif
      }
    """, '.cpp')
  context.Result(ret[0])
  return ret[0]

# configuring starts (only if we are not cleaning)
if env.GetOption('clean'):
  if os.path.exists(File(env['CONFIG_LOG']).abspath):
    os.remove(File(env['CONFIG_LOG']).abspath)
else:
  conf = Configure(env,log_file=env['CONFIG_LOG'],custom_tests = {'CheckOpenMP':CheckOpenMP} )
  if not conf.CheckType('uint32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "uint32_t". Exiting...'
    Exit(1)
  if not conf.CheckType('int32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "int32_t". Exiting...'
    Exit(1)
  if env['enableOpenmp'] and conf.CheckCXXHeader('omp.h','<>'):
    if( env['CXX'][:3] == 'g++' ): #gcc
      tmpEnv = env.Copy()
      env.Append(CPPFLAGS='-fopenmp', LIBS='-lgomp')
      
    elif ( env['CXX'][:2] == 'ic' ): #intel c compiler
      tmpEnv = env.Copy()
      env.Append(CPPFLAGS='-openmp', LINKFLAGS='-openmp')
      
    if conf.CheckOpenMP():
      print 'OpenMP support present'
    else:
      print 'OpenMP support *not* present'
      env = tmpEnv #restore the previous environment
    
  env = conf.Finish()
  # configuring ends


lib = env.SharedLibrary('numth', files)
env.Default(lib)
Alias('lib', lib)
Alias('all', lib)
env.Install(env['INSTALL_DIR_LIB'], lib)
Alias('install',env['INSTALL_DIR_LIB'])
Alias('all', 'install')

env.Append(LIBPATH = [Dir(env['INSTALL_DIR_LIB'])])
Export('env')

#if 'tests' in map(str, BUILD_TARGETS):
SConscript(dirs='tests')

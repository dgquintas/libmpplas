% TIPOS SOPORTADOS POR LA BIBLIOTECA
\chapter{Tipos soportados}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          It turns out that an eerie type of chaos can lurk just behind a
          facade of order -- and yet, deep inside the chaos lurks an even
          eerier type of order.
        }
        \begin{flushright}
          \textbf{\textemdash Douglas Hostadter}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%

\section{Consideraciones generales}
% - tipos "contenedores" (matrices, polis, etc), aseguran la coherencia
% matematica mediante comprobaciones estataticas en tiempo de compilacion
% del caracter algebraico de sus parametros, que seran sus elementos/coeficientes/whatever.

\section{El tipo general \texttt{MPPDataType}}
Formalmente, no es un tipo \emph{de dato}. Es más bien un tipo abstracto del cual todos los 
demás tipos de la biblioteca, directa o indirectamente, heredan. De hecho, la definición de
«tipo de la biblioteca» podría ser «todo tipo que tenga a \texttt{MPPDataType} como ancestro».
¿Qué ventajas aporta el contar con un tipo padre único? La experiencia de lenguajes orientados 
a objeto que --a diferencia de C++-- sí cuentan con un tipo de dato genérico ancestro común de
todos los demás demuestra que resulta efectivamente útil: por ejemplo, Java cuenta con la clase \texttt{Object},
lo cual permite por una parte definir métodos comunes para todas las demás clases, así como
poder declarar colecciones «genéricas». 

En la biblioteca, se explota la primera de estas características: el definir métodos comunes 
a todos los tipos. En concreto, y copiando a Java flagrantemente, se define como método virtual
puro \texttt{std::string toString()}, que devuelve una representación textual del dato. 
El siguiente código es por tanto válido para copiar un entero:

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Uso de \texttt{toString()}]
  Z n("123");
  Z m( n.toString() );
  
  // n == m
\end{lstlisting}
  
¿Para que hacer esto cuando se puede utilizar directamente el constructor de copia del dato? Desde luego
en situaciones en las que se tenga acceso a la \emph{instancia} del dato a ser copiado, es absurdo hacerlo 
de la forma anterior. Sin embargo, si nos encontramos con un escenario distribuido, no es trivial \textit{serializar}
\footnote{es decir, transformar una instancia arbitraria en una representación únicamente basada en tipos básicos 
susceptible de ser transferida a través de la red} una instancia de un dato arbitrario. Sin embargo sí es inmediato
serializar una cadena de caracteres. Si mediante la representación textual es posible reproducir la instancia en cuestión,
se habrá salvado este obstáculo.

La segunda y última función virtual pura declarada en el tipo \texttt{MPPDataType} es \texttt{std::string toHRString()}, en la
que «HR» corresponde a «\textit{Human Readable}»: la idea es devolver una representación textual susceptible de ser mostrada
a un usuario \emph{humano}\footnote{«usuario humano» \emph{no} es una redundancia: bien podría ser otro programa el usuario 
encargado de interpretar un resultado devuelto por la biblioteca}. En algunos casos la representación será la misma que la devuelta
por \texttt{toString()} --tal como en el caso de los enteros--, mientras que en otros será diferente --para las matrices, 
por poner un caso.

\bigskip

Poder declarar \emph{colecciones genéricas}, tales como un vector que almacene cualquier tipo de dato soportado
por la biblioteca, resulta extremadamente útil a la hora de programar de forma genérica. Un ejemplo de esto 
se encuentra en la implementación de los mecanismos de gestión de datos en tiempo de ejecución del entorno de ejemplo
desarrollado, el cual se describe en la sección \ref{par:runtimeData}

%Enteros, Z
%Reales, R
%Enteros modulares, Z\_n
%Enteros modulares con modulo primo, Z\_p

\section{Enteros modulares en el dominio de Montgomery}
Nombrados como $\mathbb{Z}M\_n$, son un tipo de entero modular, siendo
su módulo reductor $n$. Su particularidad estriba en que ninguna de sus
operaciones requiere el uso de la división, excepto en el caso de potencias
de la base de trabajo, operación que se realiza mediante desplazamientos.
  
Hasta donde se tiene constancia, se trata de un tipo de dato original
de esta biblioteca: no se tiene conocimiento de su implementación en otras bibliotecas
similares. 

\subsection{Preliminares}
Una conocida forma de exponenciación modular se basa en el método de
multiplicacion/reducción de Montgomery (\cite{montgomeryOrig}). 
El método de reducción/multiplicación se encontraba ya incorporado en
la antigua versión de la biblioteca (véase \cite{miproyecto}, sección 5.5.3),
utilizándose precisamente para la exponenciación modular. 

A lo largo de esta sección se utilizará la nomenclatura introducida en \cite{miproyecto},
sección 5.2, para los siguientes conceptos: $B$ representa la base con la que la máquina trabaja
internamente de forma óptima, en la que se representan los tipos de datos básicos \texttt{Digit}.
El número de bits de esta base se denominará $BED$: bits en \texttt{Digit}. La implementación actual
soporta valores de $BED$ de $32$ y $64$.

Es mediante la precomputación de dos valores, 
$R_n = 2^{i\cdot BED}$ con $i \in \mathbb{Z}, i \geq 1$ y $-n^{-1} \pmod{BED}$, 
que es posible prescindir de la operación de división. 
Dichos valores dependen únicamente del módulo $n$, por lo que si se realizan muchas
operaciones con el mismo módulo, el coste computacional de su cálculo se ve compensado
por la ausencia de divisiones. 

Anteriormente no se ha especificado ningún valor para la $i$ que conforma
$R_n = 2^{i \cdot BED}$. Según \cite{handbook}\footnote{pág. 600}, es suficiente con que se verifique 
$R > n$. Ahora bien, considérese la longitud del módulo $n$ en la base de trabajo $B$ definida con anterioridad
como $k$. Es posible concluir entonces 
\begin{equation}
R_n = 2^{k \cdot BED} = B^{k} \Rightarrow i = k \label{eq:defRMont}
\end{equation}
Esto simplifica e incrementa el rendimiento de las operaciones,
tal como se indica en de nuevo en \cite{handbook}\footnote{Fact 14.30 (ii), pág. 601}. Sin embargo, la limitación que esto
impone es la imposibilidad de utilizar un módulo $n$ par. De todas maneras, en los escenarios de aplicación más comunes
$n$ es primo.

Un concepto fundamental en esta discusión es el de \emph{dominio de Montgomery}.
\begin{definicion}[Dominio de Montgomery]
Se considera que $a \in \mathbb{Z}$ pertenece al \emph{dominio de Montgomery} para
un módulo $n$ si $a < n$ y $R_n | a$, esto es, si $a$ es múltiplo de $R_n$.
\end{definicion}
Las operaciones habituales de suma, resta, producto, división (como combinación de inversión más producto) 
en este dominio están bien definidas, como se expone en la sección \ref{opsZM}.


\subsection{Operaciones}
Las operaciones sobre $\mathbb{Z}M_n$ se dividen en dos grupos:
las orientadas al trabajo dentro del propio dominio, denominadas "específicas", 
y las que se corresponden con las operaciones habituales sobre $\mathbb{Z}$, 
denominadas "habituales", presentadas de cara al usuario programador.

Los detalles de implementación pueden encontrarse en el capítulo dedicado
al efecto, en la sección \ref{implZM_n}.

\subsubsection{Específicas}
\begin{definicion}[Multiplicación de Montgomery]\label{def:multMont}
Sea $R_n$ tal como se define en \eqref{eq:defRMont}, $x,y \in \mathbb{Z}$. 
Se define la función \texttt{MultMon} como
\[
  \mathtt{MultMon}(x,y,n) = x \cdot y \cdot R^{-1} \pmod{n}
\]
\end{definicion}


\begin{definicion}[Inversa de Montgomery (\cite{kaliski})]
\[
  \mathtt{InvMon}(a,n) = a^{-1} \cdot R \pmod{n}
\]
\end{definicion}


Koç y Savas ( \cite{montInvRev} ) ampliaron el
concepto, en especial con una "nueva inversa de montgomery":
\begin{definicion}[Inversa de Montgomery (\cite{montInvRev})]\label{nuevaMontInv}
Sea $R_n$ tal como se define en \eqref{eq:defRMont}, $a \in \mathbb{Z}$. 
\[
  \mathtt{NuevaInvMon}(a \cdot R,n) = a^{-1} \cdot R \pmod{n}
\]
\end{definicion}
Es decir,este último método obtiene la inversa de un número dado en el
dominio de Montgomery, manteniendose tambien el resultado en dicho dominio.

\subsubsection{Habituales}\label{opsZM}
A continuación se definen las operaciones básicas sobre este tipo 
de enteros modulares en el dominio de Montgomery, así como la conversión
hacia y desde $\mathbb{Z}$ o $\mathbb{Z}_n$.

En lo sucesivo se asume que los operandos comparten el mismo módulo
$n$.

  \paragraph{Suma y resta} 
  Sean $x,y \in \mathbb{Z}_n$,
  $0 \le xR, yR < n  \Rightarrow  xR + yR = (x+y)R \leq 2n-2$
  con lo que si la suma es mayor que $n$, bastará con restar $n$ a ésta , a lo sumo una vez

  Para la resta, el razonamiento es análogo, salvo que en este caso, el módulo habrá de
  sumarse si $(x-y)R < 0$, aunque a lo sumo tan solo dos veces.

 \paragraph{Producto} 
  Utilizando la múltiplicación de Montgomery (véase la definición \ref{def:multMont}),
  se obtiene el producto de dos elementos del dominio de Montgomery, resultando 
  en su producto también en éste, de la siguiente manera:
  $\mathtt{MultMon}( xR, yR ) = xR \cdot yR \cdot R^{-1} = xyR^2 \cdot R^{-1} = xyR$

  \paragraph{Cálculo de la inversa}
  Aplicar $\mathtt{NuevaInvMon}$ directamente (véase la definición \ref{nuevaMontInv}).
  \paragraph{División}
    La división se realiza mediante las operaciones de inversión y producto: 
    $ (aR / bR ) = \mathtt{MultMon}( aR, b^{-1}R ) = aR \cdot b^{-1}R \cdot R^{-1} = ab^{-1}R $
 
 \paragraph{Conversión desde $\mathbb{Z}$ a $\mathbb{Z}M_n$}
  Si el entero a convertir verifica $a \geq n$, se realizá previamente una reducción módulo $n$.
  Dado $0 \leq a < n$ , $\mathtt{MultMon}( a, R^2, n ) = a R^2 R^{-1} \pmod{n}  = a \cdot R \pmod{n}$

  \paragraph{Conversión desde $\mathbb{Z}M_n$ a $\mathbb{Z}$}
   Dado $0 \leq aR < n$ , $\mathtt{MultMon}( aR, 1, n ) = a R \cdot 1 \cdot R^{-1} \pmod{n} = a \pmod{n}$
   Nótese que el entero $a$ resultante se devuelve reducido módulo $n$, con lo que encajaría también 
   dentro de $\mathbb{Z}_n$ sin necesidad de una nueva reducción modular.


\subsection{Aplicaciones}
El utilizar este tipo hace que trabajar en $\mathbb{Z}_n$ sea mucho más rapido.
Como se ha mencionado anteriormente, no se realizan divisiones --la operación básica computacionalmente
más costosa. Asimismo, el cálculo del elemento inverso a uno dado
no require del uso del algoritmo extendido de Euclides 
(véase \cite{miproyecto}\footnote{sección 5.5.2, pág. 64}),
también computacionalmente costoso. 

Ahora bien, la creación y conversion desde/hacia los enteros habituales es costosa. 
Resulta conveniente mantenerse en el dominio de Montgomery durante el mayor número de
operaciones posibles. Determinados algoritmos se prestan a esto: aquellos en los que
el módulo de trabajo es común a un cierto número de operaciones, donde se utilicen
frecuentemente exponenciaciones y inversiones. Dos ejemplos de algoritmos tales son
el mecanismo de firma digital DSA (\cite{schneier}\footnote{sección 20.1, pág. 483}) 
y el mecanismo de firma y cifrado ElGamal (\cite{schneier}\footnote{sección 19.6, pág. 476}).

En la sección \label{ejZM_n} se recoge una comparativa de la implementación de estos métodos 
mediante datos en $\mathbb{Z}_n$ y $\mathbb{Z}M_n$.



%
%Polinomios
%  Sobre Z
%  Sobre R
%  Sobre Z\_p 
%
%
%Matrices
%  Sobre Z
%  Sobre R
%  Sobre GFx
%
%Vectores



\section{Polinomios}\index{tipos!Polinomios}\label{tipos:polinomios}
  En \cite{knuth}\footnote{pág. 418} se define polinomio como:

  \begin{definicion}[Polinomio]
    Un \emph{polinomio sobre \texttt{S}} es una expresión de la forma
    \begin{equation}
    u(x) = u_n x^n + \cdots + u_1 x + u_0 \label{poly}
    \end{equation}
    donde los \emph{coeficientes} $u_n,\ldots,u_1,u_0$ son elementos de algún
    sistema algebraico \texttt{S}, y la \emph{variable} $x$ puede ser considerada como 
    un símbolo formal con un valor indeterminado.

    Nótese que se considera al polinomio $0x^{n+m}+\cdots+0x^{n+1} + u_nx^n + \cdots + u_1x+u_0$ 
    equivalente a \eqref{poly}.

    Se define el \emph{grado} del polinomio \eqref{poly} como $n$, y su \emph{coeficiente director}
    como $u_n (\neq 0)$.

    Se denomina \emph{polinomio mónico} al polinomio cuyo coeficiente director es igual a $1$.

    Se denomina \emph{polinomio nulo} al polinomio cuyos coeficientes son todos igual a $0$.
  \end{definicion}

  \begin{observacion}[Caracter del sistema algebraico \texttt{S}]\label{obs:caracterS}
    Se asume que el sistema algebraico \texttt{S} es un \emph{anillo conmutativo con identidad}.
    Esto es, \texttt{S} admite operaciones de suma, resta y multiplicación, con las propiedades
    habituales. Nótese que \emph{no} se asume nada respecto a la división como operación
    inversa a la multiplicación. 
  \end{observacion}


  \begin{observacion}[Grado y coeficiente director en polinomios nulos]
    En el caso del polinomio nulo $u(x) = 0$, se define su \emph{grado} como $-\infty$; y su coeficiente
    director como $0$.
  \end{observacion}

  \subsection{Operaciones básicas sobre polinomios en \texttt{S}}
  \paragraph{Suma y resta} La suma (resp. resta) en polinomios sobre un sistema \texttt{S} se define como la suma (resp. resta) 
    sobre \texttt{S} de coeficientes de potencias iguales de $x$ (asumiendo sin pérdida de generalidad que $n > m$): 
      \begin{eqnarray}
      (u_nx^n + \cdots + u_1x + u_0) + (v_mx^m + \cdots + v_1x+v_0)  ={}  \nonumber\\
        {} = u_nx^n + \cdots + (u_m+v_m)x^m + \cdots + (u_1+v_1)x + u_0+v_0 
      \end{eqnarray}

  \paragraph{Producto} El producto se define de la siguiente manera:
      \begin{equation}
      (u_nx^n + \cdots + u_1x + u_0)(v_mx^m + \cdots + v_1x+v_0) = w_{n+m}x^{n+m} + \cdots + w_0
      \end{equation}
      tal que 
      \begin{equation}
      w_k = u_0v_k + u_1v_{k-1} + \cdots + u_{k-1}v_1 + u_kv_0
      \end{equation}
      considerándose $u_i$ o $v_j$ iguales a $0$ cuando $i > j$ o $j > s$.
      Es decir, de la misma forma que para $\mathbb{Z}$ pero sin acarreos, ya que no existe relación
      entre coeficientes vecinos. Esto conlleva que las optimizaciones
      realizadas sobre la multiplicación de enteros, tales como el método de Karatsuba 
      (véase \cite{miproyecto}\footnote{pág. 50}) y su paralelización, son directamente 
      aplicables también a este caso.

  \paragraph{División}
  \cite{knuth} dedica toda una sección --la 4.6.1, pág. 420-- al análisis de la división de polinomios.
  En general, al igual que para el producto, dos polinomios se dividen esencialmente del mismo modo
  que dos elementos de $\mathbb{Z}$, siempre y cuando \texttt{S} sea \emph{un cuerpo}. Formalmente,
  dados $u(x) = u_mx^m + \cdots + u_1x+ u_0$ y $v(x) = v_nx^n + \cdots + v_1x + v0$ con coeficientes 
  sobre un cuerpo y verificando $v_n \neq 0$ y $m \geq n \geq 0$, existe un polinomio cociente $q(x)$ 
  y un polinomio resto $r(x)$ tales que:
  \begin{equation}
    u(x) = q(x) \cdot v(x) + r(x)  \qquad grado(r) < grado(v)
  \end{equation}

  $q(x)$ y $r(x)$ toman la siguiente forma:
  \begin{eqnarray}
  q(x) & = & q_{m-n}x^{m-n} + \cdots + q_0 \\
  r(x) & = & r_{n-1}x^{n-1} + \cdots + r0 
  \end{eqnarray}

 \subsection{Máximo común divisor}\label{gcdPoly}

   \subsubsection{Con \texttt{S} un cuerpo}


   \subsubsection{Con \texttt{S} un dominio de factorización única}
      El caso más común en el que \texttt{S} cumple el requisito de ser un anillo conmutativo con identidad
      es en el caso de polinomios sobre $\mathbb{Z}$. De hecho, el sistema de los números enteros 
      verifica también el ser un \emph{dominio de factorización única}, esto es:
      \begin{definicion}[Dominio de factorización única]
        Un sistema algebraico $S$ es un \emph{dominio de factorización única} si cumple:
        \begin{itemize}
          \item $S$ es un anillo conmutativo con identidad
          \item $u,v \in S \textrm{ tal que } u, v \neq 0 \iff uv \neq 0$
          \item $\forall u \in S \textrm{ tal que } u \neq 0$, $u$ es o bien una \emph{unidad}
                \footnote{un elemento con inversa. Es decir, un elemento $u$ tal que $\exists v \in S$ tal que
                          $uv = 1$}
         o tiene una representación única como producto de \emph{primos}
        \footnote{un elemento \emph{no} unitario $p$ tal que la ecuación $p = qr$ se cumple sólo si o bien $q$ o $r$ es una unidad}.
        \end{itemize}
      \end{definicion}

      Un aspecto muy importante de los polinomios con coeficientes en $\mathbb{Z}$ es el siguiente:
    \begin{lema}[Polinomios sobre dominios de factorización única]
     Los polinomios con coeficientes en un dominio de factorización única
     forman a su vez un dominio de factorización única.
    \end{lema}

      Esto conduce a justificar la existencia y sentido de la habitual operación
      de cálculo del máximo común divisor sobre polinomios con coeficientes en un dominio de factorización
      única. 
      La especial operación de división de estos
      polinomios necesaria para implementar este método se expone a continuación.

    \paragraph{Pseudo-división de polinomios con \texttt{S} un dominio de factorización única}


  \subsection{Evaluación}
    Evaluar el valor de un polinomio $f(x)$ para un valor de $x = x_0$ dado es conceptualmente trivial:
    sustituir $x$ en la expresión del polinomio por $x_0$ y operar. Como suele ser habitual, la solución
    trivial dista de ser la óptima. De hecho, \cite{recipes} bromea con «cualquier que evalue de esta
    forma un polinomio será ejecutando de forma sumarísima». En esa obra se encuentra, en su sección 5.3, pág. 179
    un interesante análisis de la evaluación de polinomios.

    La conocida \emph{regla de Horner} evalúa un polinomio en de grado $n$ tal como el dado en \eqref{poly} 
    en $n$ productos y $n$ sumas:
    \begin{equation}
      u(x_0) = u_0 + x_0(u_1 + x_0(u_2 + \cdots + x_0(u_n) \cdots )) \label{horner}
    \end{equation}

    Aunque este método resulta a primera viste inherentemente secuencial, en la sección \ref{parallel:evalPoly}
    se muestra de que forma es posible paralelizarlo.


\section{Matrices}
%TODO
  \subsection{Instancias concretas}

  \subsection{Operaciones}
    \subsubsection{Triangularización}
    \subsubsection{Resolución de sistemas de ecuaciones}
    \subsubsection{Inversión}
    \subsubsection{Determinante}

      \begin{definicion}[Determinante]\label{def:determinante}
      Sea $A = \mathcal{M}_n$ una matriz cuadrada de tamaño $n \times n$. 
      Es posible definir su  determinante como (fórmula de Leibniz):
      \begin{equation}
        \det(A) = \sum_{\sigma \in S_n} \sgn(\sigma) \prod_{i=1}^n A_{i,\sigma(i)}. \label{eq:determinante}
      \end{equation}
      con $S_n$ el grupo de permutaciones de $n$ elementos. El sumatorio
      contempla por tanto todas las permutaciones $\sigma$ de la secuencia $\{1,2,\ldots,n\}$.
      $\sgn(\sigma)$ se corresponde a la signatura de la permutación $\sigma$: $+1$ si
      $\sigma$ es una permutación par y $-1$ si es impar.
      \end{definicion}

      Nótese que el número de sumandos según la equación \eqref{eq:determinante} es $n!$, 
      lo cual hace que no sea útil para el cálculo práctico del determinante. Detalles de los métodos
      utilizados en la biblioteca se muestran en la sección \ref{impl:determinante}
     
            


 \section{Cuerpos finitos}\label{cuerposFinitos}
  %TODO
  \subsection{Elementos de un cuerpos finitos}


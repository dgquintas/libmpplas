\chapter{Descripción general}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          Toda generalización es falsa.
        }
        \begin{flushright}
          \textbf{\textemdash Anónimo}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          People who like quotations love meaningless generalizations.
        }
        \begin{flushright}
          \textbf{\textemdash Graham Greene}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}


\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%

  
\section{Estructura general de la biblioteca}
  
  \subsection{Los procesadores virtuales}

    \paragraph{Perfilado}
      

    \subsubsection{La CPU escalar}\label{basic:cpu}

    \subsubsection{La CPU SIMD}\label{basico:cpusimd}
    Existe un tipo de paralelismo que ha estado disponible en procesadores de consumo
    desde hace más de una década, cuando en $1997$ Intel introdujo el juego de instrucciones 
    MMX en su familia de procesadores Pentium\footnote{\url{ http://www.intel.com/design/intarch/mmx/mmx.htm }}.
    Este tipo de paralelismo, denominado por las siglas SIMD\footnote{instrucción única múltiples datos, por sus siglas en inglés}, 
    se expone en la sección \ref{flynn}. Resumiendo, se trata de aplicar una única instrucción a un conjunto de datos «en bloque».
    Compárese la figura \ref{fig:sinSIMD} con la figura \ref{fig:conSIMD}. En la primera, los datos son tratados secuencialmente de
    una manera que podría denominarse «horizontal». Por contra, en la segunda, se aplica la operación en cuestión simultáneamente
    a todos los datos, «verticalmente».

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.85\textwidth,keepaspectratio]{sinSIMD} 
      \caption{Sin utilizar SIMD}\label{fig:sinSIMD}
    \end{figure}

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.85\textwidth,keepaspectratio]{conSIMD} 
      \caption{Utilizando SIMD}\label{fig:conSIMD}
    \end{figure}

    Este paralelismo intrínseco al procesador requiere el uso de instrucciones específicas del mismo, y es por ello
    difícilmente portable a otros sistemas. Asimismo, su utilización suele requerir el trabajo en lenguaje ensamblador, 
    con todo lo que ello supone (dificultad de mantenimiento, complejidad, etc.).

   La práctica ubicuidad y potencia de estos métodos los hacen muy atractivos. Con el fin de evitar el obstáculo
   de lo poco amigable de su uso, se ha desarrollado esta «CPU SIMD». Sus objetivos son:
   \begin{itemize}
      \item Aislar a las rutinas de la biblioteca que deseen hacer uso de instrucciones SIMD de la implementación
      real particular del procesador en cuestión sobre el que se esté operando. Incluso si no existe implementación
      alguna, la biblioteca provee una implementación genérica que simula su comportamiento.
      \item Homogeneizar la familia de operaciones disponibles, del mismo modo que se ha hecho con la CPU escalar.
      \item Proporcionar una abstracción adecuada que evite lidiar con los entresijos del lenguaje ensamblador. 
   \end{itemize} 

   \bigskip 

   Los «paquetes» SIMD tendrán siempre una longitud de $128$ bits. En base a esto, se han definido
   tres variedades diferentes de «paquetes» de datos SIMD:
   \begin{itemize}
   \item Pares de números en coma flotante de $64$ bits.
   \item Cuatro números en coma flotante de $32$ bits.
   \item Ocho enteros con signo de $16$ bits.
   \end{itemize}
   Los detalles de la implementación y una descripción más pormenorizada se dan en la sección \ref{simddigit}.



  \subsection{Repositorio de funciones}\label{basico:nuevoRepdeFuncs}
Ya en LibNumth exploramos la utilización de lo que se denominó «repositorio de funciones»
(véase \cite{miproyecto}\footnote{secciones 5.6 y 4.2.3}). La idea era y sigue siendo
«hacer extensible la colección de funciones \emph{sin necesidad de recompilación} por parte del usuario,
y además de forma sencilla». La implementación de este mecanismo en dicha versión de la biblioteca
era un tanto básica: dependía de convenciones en el nombrado, haciendo recaer sobre el usuario
programador la carga de recordar el nombre concreto del tipo de función que desease obtener. Por ejemplo:

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Utilizando el \textbf{antiguo} repositorio de funciones, label=lst:antiguoRepFuncs]
(...)
numth::Funciones funcs;

numth::congruentGen *LCG = new numth::congruentGen();
funcs.ponerRandom(LCG);

funcs.random()->ponerSemilla(numth::Z::convertir("323658476")); 
n = funcs.genPrimos()->leerPrimoProb(600);
(...)
\end{lstlisting}
En el anterior listado \ref{lst:antiguoRepFuncs} se aprecian los siguientes puntos:

\begin{itemize}
\item Tanto para establecer una nueva implementación 
para una clase de método, como para obtener la implementación actual, era necesario estar al tanto del
nombre de la clase de método que las instancias implementaban: \texttt{congruentGen} era un tipo de generador
de números pseudo-aleatorios, y por ello debía utilizarse el método \texttt{ponerRandom} de la clase \texttt{Funciones}, 
que representaba el repositorio. 
\item Para obtener un número primo, el programador debía recordar que el método
\texttt{genPrimos} era el indicado para obtener un puntero a una instancia generadora de primos. 
\item Incluso aunque se pretendía seguir un patrón de nombrado, éste resultaba deficiente.
\item El repositorio, instancia de la clase \texttt{Funciones}, podía instanciarse de forma arbitraria, pese a que
conceptualmente el repositorio ha de ser único durante toda la ejecución del programa. Este escollo se salvaba
haciendo que las instancias de las funciones contenidas en él fueran \texttt{static}. Este simple hecho choca frontalmente
con el concepto de \textit{thread-safety}, tal como se expone en la sección \ref{par:datosStatic}.
\end{itemize}

Esta forma de operar no sólo resulta tediosa y 
propensa a errores, sino también \emph{poco elegante}. La idea
es siempre que la máquina trabaje por nosotros, no al contrario. Por si esto fuera poco, la presencia de datos
estáticos da al traste con las aspiraciones de ejecución concurrente de la biblioteca mediante hilos. 

Compárese el código mostrado en el listado \ref{lst:antiguoRepFuncs} con el mostrado en el siguiente listado \ref{lst:nuevoRepFuncs}:
\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Utilizando el \textbf{nuevo} repositorio de funciones, label=lst:nuevoRepFuncs]
(...)
mpplas::MethodsFactory& funcs(MethodsFactory::getReference());
mpplas::RandomFast* rnd;
mpplas::PrimeGen* primes;

mpplas::RandomFast* newRnd = new mpplas::CongruentGen();
funcs.setFunc(newRnd);

funcs.getFunc(rnd);
rnd->setSeed(mpplas::Z("323658476"));

funcs.getFunc(primes);
n = primes->getInteger(600);
(...)
\end{lstlisting}
Ambas porciones de código son semánticamente equivalentes. Sin embargo:
\begin{itemize}
\item El repositorio, denominado ahora \texttt{MethodsFactory}, es ahora un \texttt{Singleton} (véase sección \ref{sec:singleton}). 
Esto lidia con los problemas de concurrencia mencionados anteriormente, haciendo que sí sea seguro utilizar esta versión del repositorio
en un entorno concurrente.
\item Se trabaja con punteros a los tipos que representan el concepto \emph{abstracto} a realizar: generar primos, obtener números
pseudo-aleatorios, etc. en vez de con los tipos que en última instancia implementan dichos conceptos.
\item El repositorio consiste \emph{únicamente} de dos métodos: \texttt{getFunc} y \texttt{setFunc}. El mecanismo
de funcionamiento, denominado \textit{autowiring}, se expone en \ref{sec:autowiring}. En este contexto, ambos
métodos inspeccionan el tipo de las instancias que les son pasadas como parámetros a la hora de asignar
o establecer las instancias pertinentes, de forma totalmente transparente para el usuario, y garantizando \emph{en tiempo
de compilación} la coherencia de dichas operaciones.
\end{itemize}

    
  \subsection{Control de errores}\label{controlDeErrores}


\section{Compilando la biblioteca}\label{estructuraGeneralDeLaLiberia}

import time, sys, os, shutil

filesStr = """
    AlgebraUtils.cpp
    CPUInfo_x86.cpp
    CRT.cpp
    Factor.cpp
    Funciones.cpp
    GCD.cpp
    Hash.cpp
    LCM.cpp
    mp.cpp
    Potencia.cpp
    Primos.cpp
    Profiling.cpp
    ProfResults.cpp
    ProfResult.cpp
    Random.cpp
    R.cpp
    RedModular.cpp
    Semillero.cpp
    SimbolosLegendre.cpp
    SystemInfo.cpp
    Trascendentes.cpp
    Z.cpp
    Z_n.cpp
    ZM_n.cpp
    VectorZ.cpp
    VectorR.cpp
    MatrixZ.cpp
    MatrixR.cpp
    """


#############################################################
#                    SUPPORT FUNCTIONS                      #
#############################################################
def getNativelySupportedArchs():
  natArchs = ['generic']
  x86ArchMachines = ['i386', 'i486', 'i586', 'i686', 'x86_64']
  currentPlatformMachine = platform.machine()

  
  if currentPlatformMachine in x86ArchMachines:
    natArchs.append('x86')
    if currentPlatformMachine == 'x86_64':
      natArchs.append('x86_64')
  elif currentPlatformMachine == 'Power Macintosh':
    natArchs.append('ppc')

  return tuple(natArchs)


def manually_insert(inputPath,outputPath,conditions):
  import re
  from os.path import dirname,abspath
  from os import getcwd, chdir, remove
  from tempfile import mkstemp
  oldPWD = getcwd()
  chdir(dirname(abspath(inputPath)))
  input = open(inputPath,'r')
  output = open(outputPath, 'w')
  pragma_str = "#pragma __libmpplas_manual_include"
  for line in input.xreadlines():
    if line.strip()[:len(pragma_str)] == "#pragma __libmpplas_manual_include":
      no_condition = False
      cond_read = ""
      if len(line.split()) == 2: #no cond
        no_condition = True
      else:
        cond_read = line.split()[2]
      include_line = input.next()
      if cond_read in conditions or no_condition:
        m = re.match(r'#include "([a-zA-Z0-9\_\.]+)"', include_line.strip())
        file_to_include = m.group(1)
        #parse input file for possible substitutions as well
        tmpOutFile = mkstemp()[1]
        manually_insert( file_to_include, tmpOutFile, conditions)
        tmpOutFileDesc = open(tmpOutFile, 'r')
        output.write(tmpOutFileDesc.read())
        tmpOutFileDesc.close()
        remove( tmpOutFile )
    else:
      output.write(line)
  chdir(oldPWD)
  input.close()
  output.close()

Import('env')





env.Append(CCFLAGS = ' -pipe ')
env.Append(CCFLAGS = ' -O' + env['optLevel'])

  
try:
  import platform

  if env['arch'] not in getNativelySupportedArchs():
    print "\nWARNING: the selected architecture (" + env['arch'] + ") is not natively supported by this system"
    for i in xrange(3):
      time.sleep(1)
      print '.',
      sys.stdout.flush()
    else:
      print ''
#  env['SYSTEMBITS'] = platform.architecture()[0][:2]

except ImportError:
  print "Platform support checking not supported by the Python installed: " + sys.version
#  env['SYSTEMBITS'] = "32"

env.Append(CPPDEFINES = 'ARCH_' + env['arch'] )

if env['arch'][:6] == 'x86_64':
  env.Append(CPPDEFINES = [('ARCHBITS', '64')])
  env['ARCHBITS'] = '64'
  env.Append(CCFLAGS = ' -m64 ')
  env.Append(LINKFLAGS = ' -m64 ')

else:
  env.Append(CPPDEFINES = [('ARCHBITS', '32')])
  env['ARCHBITS'] = '32' 
  env.Append(CCFLAGS = ' -m32 ')
  env.Append(LINKFLAGS = ' -m32 ')


if env['enableRelease']:
  env.Append(CPPDEFINES = ['RELEASE','NDEBUG'])
 


#if env['enableExtraOpt']: 
#  env.Append(CCFLAGS = ' -ffast-math')  #FIXME: esto con icc no chuta

if env['enableDebug']:
  env.Append(CCFLAGS = ' -ggdb3')



if env['enableWarnings']:
  env.Append(CCFLAGS = ' -Wall -W')
#options processing ends

def CheckSIMD(context):
  context.Message('Checking for SIMD instructions support... ')
  ret = context.TryRun(
    r"""
      #include <iostream>
      #include <string>
      int main(){
      std::string res("[");
      uint32_t eax, edx, ecx;
      eax = 1;
      asm ( "cpuid;"
        : "=d"(edx), "=c"(ecx)
        : "a"(eax)
        );
      if( edx & (1L << 23) ){ res += "\"MMX\"" ; }
      if( edx & (1L << 25) ){ res += ", \"SSE\"" ; }
      if( edx & (1L << 26) ){ res += ", \"SSE2\"" ;}
      if( ecx & (1L) ){ res += ", \"SSE3\"" ; }
      if( ecx & (1L << 9) ){ res += ", \"SSSE3\"" ; } 
      res += "]";
      std::cout << res ;
      return 0;
      }
    """, '.cpp')
  if ret[0]:
    context.env["SIMD"] = ret[1]
  context.Result(ret[0])
  return ret[0]
      

def CheckOpenMP(context):
  context.Message('Checking for OpenMP support... ')
  ret = context.TryRun( 
    """
      #include <omp.h>
      int main(){
        #ifdef _OPENMP
          return 0;
        #else
          return 1;
        #endif
      }
    """, '.cpp')
  context.Result(ret[0])
  return ret[0]

# configuring starts (only if we are not cleaning)
if env.GetOption('clean'):
  if os.path.exists(File(env['CONFIG_LOG']).abspath):
    os.remove(File(env['CONFIG_LOG']).abspath)
else:
  conf = Configure(env,log_file=env['CONFIG_LOG'],custom_tests = {'CheckOpenMP':CheckOpenMP , 'CheckSIMD':CheckSIMD} )
  if not conf.CheckType('uint32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "uint32_t". Exiting...'
    Exit(1)

  if not conf.CheckType('int32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "int32_t". Exiting...'
    Exit(1)

  if env['enableSIMD'] != 'nosimd' and conf.CheckSIMD():
    msg = "SIMD instructions present: " + str(env['SIMD']) + ". "
    if env['enableSIMD'] == "sse2" and "SSE2" in env['SIMD']:
      env.Append(CPPFLAGS=' -msse2 ')
      msg += "Using SSE2"
    elif env['enableSIMD'] == "sse" and "SSE" in env['SIMD']:
      env.Append(CPPFLAGS=' -msse ')
      msg += "Using SSE"
    print msg
  else: # simd = nosimd
    print "SIMD instructions *not* present or disabled"
  
  env.Append(CPPDEFINES = 'USESIMD_' + env['enableSIMD'] )

  if env['enableOpenmp']:
    if conf.CheckCXXHeader('omp.h','<>'):
      if( env['CXX'][:3] == 'g++' ): #gcc
        tmpEnv = env.Copy()
        env.Append(CPPFLAGS=' -fopenmp ', LIBS='-lgomp')
        
      elif ( env['CXX'][:2] == 'ic' ): #intel c compiler
        tmpEnv = env.Copy()
        env.Append(CPPFLAGS=' -openmp ', LINKFLAGS='-openmp')
        
      if conf.CheckOpenMP():
        print 'OpenMP support present'
      else:
        print 'OpenMP support *not* present'
        env = tmpEnv #restore the previous environment
        filesStr += ' omp_mock.cpp '
    else: #failed omp.h header check
      filesStr += ' omp_mock.cpp '
  else:
    filesStr += ' omp_mock.cpp '
      
  env = conf.Finish()
  # configuring ends

kernelsDir = '#/src/sources/nucleo/'
if env['enableAOPProf']:
  if not env.GetOption('clean'):
    from os import system
    from os import getcwd, chdir
    oldCWD = getcwd()
    chdir(str(Dir(kernelsDir)))
    manually_insert( str(Dir(kernelsDir+ 'nucleo.h')) , str(Dir(kernelsDir+ 'aop/nucleo.h')) , ( env['arch'], env['enableSIMD'] ) )
    kernelsDir += 'aop/'
    Execute(Delete( './aop/out'))
    chdir(str(Dir(kernelsDir)))
    simdDefs = ""
    if env['enableSIMD'] == "sse2":
      simdDefs = "-D__SSE2__ -D__SSE__ -D__MMX__"
    elif env['enableSIMD'] == "sse":
      simdDefs = "-D__SSE__ -D__MMX__"
    AOPCommand = "ac++ -DUSESIMD_%s %s -DARCH_%s -DARCHBITS=%d -p . -I %s -d ./out"  \
                  % ( env['enableSIMD'], simdDefs, env['arch'], env['archbits'], Dir('#/src/headers') )
    kernelsDir += 'out/'
    print AOPCommand
    system(AOPCommand)
    chdir(oldCWD)

env.Append( CPPPATH=[kernelsDir] )


env.Append(CPPDEFINES = [('SVN_REV', env['SVN_REV'])])

files = Split(filesStr)

lib = env.SharedLibrary('mpplas', files)
env.Default(lib)
Alias('lib', lib)
Alias('all', lib)
env.Install(env['INSTALL_DIR_LIB'], lib)
Alias('install',env['INSTALL_DIR_LIB'])
Alias('all', 'install')
env.Clean('all', '#/src/sources/nucleo/aop/out/')
env.Clean('all', '#/src/sources/nucleo/aop/nucleo.h')

env.Append(LIBPATH = [Dir(env['INSTALL_DIR_LIB'])])
Export('env')

#if 'tests' in map(str, BUILD_TARGETS):
SConscript(dirs='tests')

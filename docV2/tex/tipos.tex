% TIPOS SOPORTADOS POR LA BIBLIOTECA
\chapter{Tipos soportados}\label{chap:tipos}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          It turns out that an eerie type of chaos can lurk just behind a
          facade of order -- and yet, deep inside the chaos lurks an even
          eerier type of order.
        }
        \begin{flushright}
          \textbf{\textemdash Douglas Hostadter}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          God is Real, unless declared Integer
        }
        \begin{flushright}
          \textbf{\textemdash J. Allan Toogood}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%

\section{Introducción}
En la figura \ref{fig:jerarquiaTipos} se muestran los distintos tipos y una
visión general de sus interrelaciones. 
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth,keepaspectratio]{jerarquiaTipos} 
    \caption{Tipos de la biblioteca}\label{fig:jerarquiaTipos}
  \end{figure}
Los tipos denominados compuestos, las matrices y los polinomios, reciben un tipo
como argumento de plantilla: el tipo de sus elementos. Este concepto de tipo de
plantilla es, claro está, propio de C++, no de la biblioteca. Sin embargo, como se
expone en detalle en \ref{categorizacionAlgebraica}, se han incorporado mecanismos 
para asegurar que la coherencia matemática se mantiene. También en dicha sección, 
concretamente en la figura \ref{fig:categoriasAlgebraicas}, se presenta el modo en el que
para cada tipo se ha modelado su categoría algebraica. 

Respecto a LibNumth, la familia de tipos disponibles ha aumentado cuantitativa y cualitativamente.
No sólo se han añadido tipos completamente nuevos, sino que se han refinado los ya presentes. Por ejemplo,
el cuerpo $\mathbb{Z}_p$ que antes podía modelarse únicamente mediante $\mathbb{Z}_n$ con un $n$ primo, ahora cuenta
con tipo propio, lo que permite sacar partido de sus características particulares como cuerpo: $\mathbb{Z}_n$ sólo
puede ser considerado como anillo si no se imponen restricciones sobre el módulo $n$.


\section{El tipo general \texttt{MPPDataType}}\label{tipos:mppdatatype}
Formalmente, no es un tipo \emph{de dato}. Es más bien un tipo abstracto del cual todos los 
demás tipos de la biblioteca, directa o indirectamente, heredan. De hecho, la definición de
«tipo de la biblioteca» podría ser «todo tipo que tenga a \texttt{MPPDataType} como ancestro».
¿Qué ventajas aporta el contar con un tipo padre único? La experiencia de lenguajes orientados 
a objeto que --a diferencia de C++-- sí cuentan con un tipo de dato genérico ancestro común de
todos los demás demuestra que resulta efectivamente útil: por ejemplo, Java cuenta con la clase \texttt{Object},
lo cual permite por una parte definir métodos comunes para todas las demás clases, así como
poder declarar colecciones «genéricas». 

En la biblioteca, se explota la primera de estas características: el definir métodos comunes 
a todos los tipos. En concreto, y copiando a Java flagrantemente, se define como método virtual
puro \texttt{std::string toString()}, que devuelve una representación textual del dato. 
El siguiente código es por tanto válido para copiar un entero:

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Uso de \texttt{toString()}]
  Z n("123");
  Z m( n.toString() );
  
  // n == m
\end{lstlisting}
  
¿Para que hacer esto cuando se puede utilizar directamente el constructor de copia del dato? Desde luego
en situaciones en las que se tenga acceso a la \emph{instancia} del dato a ser copiado, es absurdo hacerlo 
de la forma anterior. Sin embargo, si nos encontramos con un escenario distribuido, no es trivial \textit{serializar}
\footnote{es decir, transformar una instancia arbitraria en una representación únicamente basada en tipos básicos 
susceptible de ser transferida a través de la red} una instancia de un dato arbitrario. Sin embargo sí es inmediato
serializar una cadena de caracteres. Si mediante la representación textual es posible reproducir la instancia en cuestión,
se habrá salvado este obstáculo.

La segunda y última función virtual pura declarada en el tipo \texttt{MPPDataType} es \texttt{std::string toHRString()}, en la
que «HR» corresponde a «\textit{Human Readable}»: la idea es devolver una representación textual susceptible de ser mostrada
a un usuario \emph{humano}\footnote{«usuario humano» \emph{no} es una redundancia: bien podría ser otro programa el usuario 
encargado de interpretar un resultado devuelto por la biblioteca}. En algunos casos la representación será la misma que la devuelta
por \texttt{toString()} --tal como en el caso de los enteros--, mientras que en otros será diferente --para las matrices, 
por poner un caso--.

\bigskip

Poder declarar \emph{colecciones genéricas}, tales como un vector que almacene cualquier tipo de dato soportado
por la biblioteca, resulta extremadamente útil a la hora de programar de forma genérica. Un ejemplo de esto 
se encuentra en la implementación de los mecanismos de gestión de datos en tiempo de ejecución del entorno de ejemplo
desarrollado, el cual se describe en la sección \ref{par:runtimeData}.

%Enteros, Z
\section{Enteros}
  La base de los demás tipos, ya sea por herencia o composición; es decir, formando un subconjunto --como en el caso 
  de $\mathbb{Z}_n$-- o siendo utilizados internamente en las representaciones --como en $\mathbb{R}$--. El grueso 
  de su implementación base proviene de LibNumth. Sin embargo se han realizado optimizaciones y añadido algunos métodos
  en esta nueva versión de la biblioteca. %TODO: cuales?

\section{Enteros modulares}
  En Teoría de Números, y por extensión en criptografía, se utilizan con mucha frecuencia enteros modulares. 
  Pese a que forman un subconjunto de los enteros, y que toda operación sobre un entero modular puede reducirse
  en última instancia a operaciones sobre los enteros habituales, es posible aprovecharse de sus características
  particulares. Esto justifica su modelado por separado. 
  %TODO

  \subsection{Enteros módulo un primo}
    Si en $\mathbb{Z}_n$ se restringe el módulo $n$ a números primos, es un resultando básico en Teoría de Números %TODO: cita
    que la estructura algebraica resultante, usualmente denominada $\mathbb{Z}_p$, tiene carácter de \emph{cuerpo}. 
    Esto es, se garantiza la existencia de inversa para todo elemento no nulo. La relevancia de esta estructura
    en Teoría de Números es muy grande. %TODO: aplicaciones

    La biblioteca modela a esta estructura de forma independiente, no como un mero caso particular de $\mathbb{Z}_n$, sacando
    partido de los mecanismos de categorización algebraica de la misma. 

  \subsection{Enteros modulares en el dominio de Montgomery}\label{sec:zm}
  Nombrados como $\mathbb{Z}M_n$, son un tipo de entero modular, siendo
  su módulo reductor $n$. Su particularidad estriba en que ninguna de sus
  operaciones requiere el uso de la división, excepto en el caso de potencias
  de la base de trabajo, operación que se realiza mediante desplazamientos.
    
  Hasta donde se tiene constancia, se trata de un tipo de dato original
  de esta biblioteca: no se tiene conocimiento de su implementación en otras bibliotecas
  similares. 

  \subsubsection{Preliminares}
  Una conocida forma de exponenciación modular se basa en el método de
  multiplicación/reducción de Montgomery (\cite{montgomeryOrig}). 
  El método de reducción-multiplicación se encontraba ya incorporado en
  la antigua versión de la biblioteca (véase \cite{miproyecto}, sección 5.5.3),
  utilizándose precisamente para la exponenciación modular. 

  A lo largo de esta sección se utilizará la nomenclatura introducida en \cite{miproyecto},
  sección 5.2, para los siguientes conceptos: $B$ representa la base con la que la máquina trabaja
  internamente de forma óptima, en la que se representan los tipos de datos básicos \texttt{Digit}.
  El número de bits de esta base se denominará $BED$: bits en \texttt{Digit}. La implementación actual
  soporta valores de $BED$ de $32$ y $64$.

  Mediante la precomputación de dos valores, 
  $R_n = 2^{i\cdot BED} \mid i \in \mathbb{Z}, i \geq 1$ y $-n^{-1} \pmod{BED}$, 
  resulta posible prescindir de la operación de división. 
  Dichos valores dependen únicamente del módulo $n$, por lo que si se realizan muchas
  operaciones con el mismo módulo, el coste computacional de su cálculo se ve compensado
  por la ausencia de divisiones. 

  Anteriormente no se ha especificado ningún valor para la $i$ en
  $R_n = 2^{i \cdot BED}$. Según \cite{handbook}\footnote{pág. 600}, es suficiente con que se verifique 
  $R > n$. Ahora bien, considérese la longitud del módulo $n$ en la base de trabajo $B$ definida con anterioridad
  como $k$. Es posible concluir entonces 
  \begin{equation}
  R_n = 2^{k \cdot BED} = B^{k} \Rightarrow i = k \label{eq:defRMont}
  \end{equation}
  Esto simplifica e incrementa el rendimiento de las operaciones,
  tal como se indica en  \cite{handbook}\footnote{Fact 14.30 (ii), pág. 601}. Sin embargo, la limitación que esto
  impone es la imposibilidad de utilizar un módulo $n$ par. De todas maneras, en los escenarios de aplicación más comunes
  $n$ es primo.

  Un concepto fundamental en esta discusión es el de \emph{dominio de Montgomery}.
  \begin{definicion}[Dominio de Montgomery]
  Se considera que $a \in \mathbb{Z}$ pertenece al \emph{dominio de Montgomery} para
  un módulo $n$ si $a < n$ y $R_n | a$, esto es, si $a$ es múltiplo de $R_n$.
  \end{definicion}
  Las operaciones habituales de suma, resta, producto, división (como combinación de inversión más producto) 
  en este dominio están bien definidas, como se expone en la sección \ref{opsZM}.


  \subsubsection{Operaciones}
  Las operaciones sobre $\mathbb{Z}M_n$ se dividen en dos grupos:
  las orientadas al trabajo dentro del propio dominio, denominadas «específicas», 
  y las que se corresponden con las operaciones habituales sobre $\mathbb{Z}$, 
  denominadas «habituales», presentadas de cara al usuario programador.

  Los detalles de implementación pueden encontrarse en el capítulo dedicado
  al efecto, en la sección \ref{implZM_n}.

  \paragraph{Específicas.}
  \begin{definicion}[Multiplicación de Montgomery]\label{def:multMont}
  Sea $R_n$ tal como se define en la expresión \eqref{eq:defRMont}, $x,y \in \mathbb{Z}$. 
  Se define la función \texttt{MultMon} como
  \[
    \mathtt{MultMon}(x,y,n) = x \cdot y \cdot R^{-1} \pmod{n}
  \]
  \end{definicion}


  \begin{definicion}[Inversa de Montgomery (\cite{kaliski})]\label{def:invMont}
  \[
    \mathtt{InvMon}(a,n) = a^{-1} \cdot R \pmod{n}
  \]
  \end{definicion}


  Koç y Savas (\cite{montInvRev}) ampliaron el
  concepto, en especial con una «nueva inversa de Montgomery»:
  \begin{definicion}[Inversa de Montgomery (\cite{montInvRev})]\label{nuevaMontInv}
  Sea $R_n$ tal como se define en la expresión \eqref{eq:defRMont}, $a \in \mathbb{Z}$. 
  \[
    \mathtt{NuevaInvMon}(a \cdot R,n) = a^{-1} \cdot R \pmod{n}
  \]
  \end{definicion}
  Es decir,este último método obtiene la inversa de un número dado en el
  dominio de Montgomery, manteniéndose también el resultado en dicho dominio.

  \paragraph{Habituales.}\label{opsZM}
  A continuación se definen las operaciones básicas sobre este tipo 
  de enteros modulares en el dominio de Montgomery, así como la conversión
  hacia y desde $\mathbb{Z}$ ó $\mathbb{Z}_n$.

  En lo sucesivo se asume que los operandos comparten el mismo módulo
  $n$.

  \subparagraph{Suma y resta} 
  Sean $x,y \in \mathbb{Z}_n$,
  $0 \le xR, yR < n  \Rightarrow  xR + yR = (x+y)R \leq 2n-2$
  con lo que si la suma es mayor que $n$, bastará con restar $n$ a ésta a lo sumo una vez.

  Para la resta, el razonamiento es análogo, salvo que en este caso, el módulo habrá de
  sumarse si $(x-y)R < 0$, a lo sumo dos veces.

 \subparagraph{Producto} 
  Utilizando la multiplicación de Montgomery (véase la definición \ref{def:multMont}),
  se obtiene el producto de dos elementos del dominio de Montgomery, resultando 
  en su producto también en éste, de la siguiente manera:
  $\mathtt{MultMon}( xR, yR ) = xR \cdot yR \cdot R^{-1} = xyR^2 \cdot R^{-1} = xyR$

  \subparagraph{Cálculo de la inversa}
  Aplicar $\mathtt{NuevaInvMon}$ directamente (véase la definición \ref{nuevaMontInv}).
  \subparagraph{División}
    La división se realiza mediante las operaciones de inversión y producto: 
    $ (aR / bR ) = \mathtt{MultMon}( aR, b^{-1}R ) = aR \cdot b^{-1}R \cdot R^{-1} = ab^{-1}R $
 
 \subparagraph{Conversión desde $\mathbb{Z}$ a $\mathbb{Z}M_n$}
  Si el entero a convertir verifica $a \geq n$, se realizar  previamente una reducción módulo $n$.
  Dado $0 \leq a < n$ , $\mathtt{MultMon}( a, R^2, n ) = a R^2 R^{-1} \pmod{n}  = a \cdot R \pmod{n}$

  \subparagraph{Conversión desde $\mathbb{Z}M_n$ a $\mathbb{Z}$}
   Dado $0 \leq aR < n$ , $\mathtt{MultMon}( aR, 1, n ) = a R \cdot 1 \cdot R^{-1} \pmod{n} = a \pmod{n}$
   Nótese que el entero $a$ resultante se devuelve reducido módulo $n$, con lo que encajaría también 
   dentro de $\mathbb{Z}_n$ sin necesidad de una nueva reducción modular.


  \subsubsection{Aplicaciones}
  El utilizar este tipo hace que trabajar en $\mathbb{Z}_n$ sea mucho más rápido.
  Esto es debido a que, como se ha mencionado anteriormente, 
  no se realizan divisiones --el «algoritmo básico»\footnote{
  la división \emph{no} es una operación básica como erróneamente 
  suele considerarse. Tan solo la suma y el producto (para las estructuras
  algebraicas donde tuviera lugar) lo son.}
   computacionalmente
  más costoso. Asimismo, el cálculo del elemento inverso a uno dado
  no requiere del uso del algoritmo extendido de Euclides 
  (véase \cite{miproyecto}\footnote{sección 5.5.2, pág. 64}),
  también computacionalmente costoso. 

  Ahora bien, la creación y conversión desde/hacia los enteros habituales es costosa. 
  Resulta conveniente mantenerse en el dominio de Montgomery durante el mayor número de
  operaciones posibles. Determinados algoritmos se prestan a esto: aquellos en los que
  el módulo de trabajo es común a un cierto número de operaciones, donde se utilicen
  frecuentemente exponenciaciones e inversiones. Dos ejemplos de algoritmos tales son
  el mecanismo de firma digital DSA (\cite{schneier}\footnote{sección 20.1, pág. 483}) 
  y el mecanismo de firma y cifrado ElGamal (\cite{schneier}\footnote{sección 19.6, pág. 476}).

  %TODO
  %En la sección \ref{ejZM_n} se recoge una comparativa de la implementación de estos métodos 
  %mediante datos en $\mathbb{Z}_n$ y $\mathbb{Z}M_n$.


\section{Reales}
  %TODO

  \subsection{Cálculo de la raíz cuadrada}\label{tipos:sqrt}
  La función $\sqrt{A}$, puede definirse como las raíces de la función $f(x) = x^2 - A$. Esto lleva a pensar
  inmediatamente en la utilización de un método iterativo para el cálculo de raíces. Por ejemplo, el conocido
  método de Newton --descrito por ejemplo en \cite{recipes,calculoburgos}\footnote{sección 9.4, pág. 366; sección 092, pág. 
  258, resp.}--, lo que nos llevaría a la siguiente formulación:
  \begin{eqnarray}
   x_{n+1} & = & x_n - \frac{f(x_n)}{f'(x_n)} =  \nonumber \\
           & = & \frac{1}{2} \left( x_n + \frac{A}{x_n}  \right) \label{newtonDiv}
  \end{eqnarray}
  
  Este método es eficaz, tanto en cuanto devuelve efectivamente un resultado correcto para $\sqrt{A}$. 
  Sin embargo, adolece de un problema desde el punto de vista del rendimiento en la práctica: en la
  expresión \eqref{newtonDiv}, se requiere realizar la división $A / x_n$ en cada paso. 

  Con un pequeño ajuste (\cite{sqrt}) es posible evitar esta división y realizar solamente multiplicaciones, con la 
  consiguiente mejora de rendimiento. Considérese la función $f(x) = 1/x^2 - A$, es decir, el cálculo
  de la inversa de la raíz cuadrada, $1/\sqrt{A}$. En este caso,
  \begin{equation}
    x_{n+1} = \frac{3}{2} x_n - \frac{1}{2}Ax_n^3 \label{newton2}
  \end{equation}

  Como se ha dicho, esta iteración converge a $1/\sqrt{A}$. Multiplicando este valor por $A$, se 
  obtiene el deseado valor de $\sqrt{A}$, como es sencillo demostrar tras unas simples manipulaciones
  algebraicas: $ (1 / \sqrt{x}) \equiv (\sqrt{x} / (\sqrt{x})^2) = \sqrt{x}/x$, por lo que
  $(\sqrt{x}/x)x = \sqrt{x}$.

  La iteración definida en \eqref{newton2} tiene convergencia cuadrática. Es posible ir mas allá. Por ejemplo,
  en \cite{sqrt} se aplica el método de Newton dos veces, lo cual resulta en una convergencia cuádruple:

  \begin{equation}
  x_{n+1} = x_n - \frac{x_n}{16}(1-Ax^2_n)(-20 + 19A x^2_n - 8A^2 x^4_n + A^3 x^6_n) \label{newton3}
  \end{equation}

  Pero una vez más, todavía puede mejorarse. Dada la regularidad de $f$, resulta posible aplicar
  una variante también cuádruple del método de Newton dada en \cite{newton}\footnote{sección 4.2}:
  
  \begin{equation}
  x_{n+1} = x_n - \frac{x_n}{16}(1-Ax^2_n)(-19 + 16Ax^2_n - 5A^2 x^4_n) \label{newton4}
  \end{equation}

  Si se comparan las expresiones \eqref{newton3} y \eqref{newton4}, vemos como la segunda
  resulta computacionalmente más sencilla de evaluar dado el menor order del polinomio
  que contiene, aún manteniendo su orden de convergencia. Reformulando:

  \begin{equation}
  \left\{ 
    \begin{array}{l}
      h_n = 1 - Ax^2_n \\
      x_{n+1} = x_n + \frac{x_n}{16} \left(  8h_n + 6h^2_n +5h^3_n \right) \label{eq:sqrtFinal}
    \end{array} 
  \right.
  \end{equation}


  Véase la sección \ref{impl:sqrt} para detalles específicos de la implementación.

  \subsection{Funciones trascendentes}
    Se define como \emph{transcendente} toda función no algebraica. En otras palabras,
    que no puede expresarse en términos algebraicos. Su denominación deriva del hecho
      de «trascender» al Álgebra.

      Se han incorporado a la biblioteca métodos para el cálculo de las siguientes
      funciones trascendentes.
    \begin{description}
      \item[Exponencial.] Operación representada usualmente como $exp(x) = e^x$, siendo 
       $e$ la base de los logaritmos neperianos. Esta funcion, antiguamente denominada como
       «la e-función de Euler» (\cite{oxfordmath}\footnote{pág. 51}), tiene el siguiente valor:
       $exp(1) = e = 1 + 1 + \frac{1}{2!} + \frac{1}{3!} + \cdots \approx 2.7182\ldots$. 
       Esta constante $e$ encierra muchas otras sorpresas, siendo básica en el estudio 
       de cuerpo de los número complejos. Se combina con otras dos célebres constantes en la
       conocida y sorprendente, a primera vista, expresión $e^{i \pi} = -1$.
      \item[Logaritmo neperiano.] Operación inversa a la exponencial, para $y = \ln{(x)}$,
        se verifica $e^y = x$. Nótese que el cálculo del logaritmo en otra base $b$
          distinta de $e$ se reduce a: $\log_b{(x)} = \ln{(x)} / \ln{(b)}$.
      \item[Funciones trigonométricas.] Es decir, las funciones seno y coseno, así como las
      derivadas de éstas, como la tangente. 
    \end{description}

    \subsubsection{Cálculo de $\pi$}
      El cálculo de la proporción entre la longitud y diámetro de la circunferencia, más
      conocida como $\pi$, es un cálculo clásico utilizado habitualmente como prueba
      ya sea de rendimiento o de correcto funcionamiento por parte de bibliotecas o paquetes
      de cálculo numérico. En el caso que nos ocupa no se ha pretendido realizar una implementación
      que vaya a batir marcas de rendimiento, sino más bien implementar uno mismo uno de los muchos
      métodos disponibles para el cálculo de una de las constante más famosas.

      

\section{Polinomios}\index{tipos!Polinomios}\label{tipos:polinomios}
  En \cite{knuth}\footnote{pág. 418} se define polinomio como:

  \begin{definicion}[Polinomio]
    Un \emph{polinomio sobre \texttt{S}} es una expresión de la forma
    \begin{equation}
    u(x) = u_n x^n + \cdots + u_1 x + u_0 \label{poly}
    \end{equation}
    donde los \emph{coeficientes} $u_n,\ldots,u_1,u_0$ son elementos de algún
    sistema algebraico \texttt{S}, y la \emph{variable} $x$ puede ser considerada como 
    un símbolo formal con un valor indeterminado.

    Nótese que se considera al polinomio $0x^{n+m}+\cdots+0x^{n+1} + u_nx^n + \cdots + u_1x+u_0$ 
    equivalente a \eqref{poly}.

    Se define el \emph{grado} del polinomio \eqref{poly} como $n$, y su \emph{coeficiente director}
    como $u_n (\neq 0)$.

    Se denomina \emph{polinomio mónico} al polinomio cuyo coeficiente director es igual a $1$.

    Se denomina \emph{polinomio nulo} al polinomio cuyos coeficientes son todos igual a $0$.
  \end{definicion}

  \begin{observacion}[Caracter del sistema algebraico \texttt{S}]\label{obs:caracterS}
    Se asume que el sistema algebraico \texttt{S} es un \emph{anillo conmutativo con identidad}.
    Esto es, \texttt{S} admite operaciones de suma, resta y multiplicación, con las propiedades
    habituales. Nótese que \emph{no} se asume nada respecto a la división como operación
    inversa a la multiplicación. 
  \end{observacion}


  \begin{observacion}[Grado y coeficiente director en polinomios nulos]
    En el caso del polinomio nulo $u(x) = 0$, se define su \emph{grado} como $-\infty$; y su coeficiente
    director como $0$.
  \end{observacion}

  \subsection{Operaciones básicas sobre polinomios en \texttt{S}}
  \subsubsection{Suma y resta} La suma (resp. resta) en polinomios sobre un sistema \texttt{S} se define como la suma (resp. resta) 
    sobre \texttt{S} de coeficientes de potencias iguales de $x$ (asumiendo sin pérdida de generalidad que $n > m$): 
      \begin{eqnarray}
      (u_nx^n + \cdots + u_1x + u_0) + (v_mx^m + \cdots + v_1x+v_0)  ={}  \nonumber\\
        {} = u_nx^n + \cdots + (u_m+v_m)x^m + \cdots + (u_1+v_1)x + u_0+v_0 
      \end{eqnarray}

  \subsubsection{Producto} El producto se define de la siguiente manera:
      \begin{equation}
      (u_nx^n + \cdots + u_1x + u_0)(v_mx^m + \cdots + v_1x+v_0) = w_{n+m}x^{n+m} + \cdots + w_0
      \end{equation}
      tal que 
      \begin{equation}
      w_k = u_0v_k + u_1v_{k-1} + \cdots + u_{k-1}v_1 + u_kv_0
      \end{equation}
      considerándose $u_i$ o $v_j$ iguales a $0$ cuando $i > j$ ó $j > s$.
      Es decir, de la misma forma que para $\mathbb{Z}$ pero sin acarreos, ya que no existe relación
      entre coeficientes vecinos. Esto conlleva que las optimizaciones
      realizadas sobre la multiplicación de enteros, tales como el método de Karatsuba 
      (véase \cite{miproyecto}\footnote{pág. 50}) y su paralelización, son directamente 
      aplicables también a este caso.

  \subsubsection{División}
  \cite{knuth} dedica toda una sección --la 4.6.1, pág. 420-- al análisis de la división de polinomios.
  En general, al igual que para el producto, dos polinomios se dividen esencialmente del mismo modo
  que dos elementos de $\mathbb{Z}$, siempre y cuando \texttt{S} sea un \emph{cuerpo}. Formalmente,
  dados $u(x) = u_mx^m + \cdots + u_1x+ u_0$ y $v(x) = v_nx^n + \cdots + v_1x + v0$ con coeficientes 
  sobre un cuerpo y verificando $v_n \neq 0$ y $m \geq n \geq 0$, existe un polinomio cociente $q(x)$ 
  y un polinomio resto $r(x)$ tales que:
  \begin{equation}
    u(x) = q(x) \cdot v(x) + r(x)  \qquad \mathrm{grado}(r) < \mathrm{grado}(v)
  \end{equation}

  $q(x)$ y $r(x)$ toman la siguiente forma:
  \begin{eqnarray}
  q(x) & = & q_{m-n}x^{m-n} + \cdots + q_0 \\
  r(x) & = & r_{n-1}x^{n-1} + \cdots + r0 
  \end{eqnarray}

 \subsection{Máximo común divisor}\label{gcdPoly}
  %TODO

   \subsubsection{Con \texttt{S} un cuerpo}
    %TODO


   \subsubsection{Con \texttt{S} un dominio de factorización única}
      El caso más común en el que \texttt{S} cumple el requisito de ser un anillo conmutativo con identidad
      es en el caso de polinomios sobre $\mathbb{Z}$. De hecho, el sistema de los números enteros 
      verifica también el ser un \emph{dominio de factorización única}, esto es:
      \begin{definicion}[Dominio de factorización única]
        Un sistema algebraico $S$ es un \emph{dominio de factorización única} si cumple:
        \begin{itemize}
          \item $S$ es un anillo conmutativo con identidad
          \item $u,v \in S \textrm{ tal que } u, v \neq 0 \iff uv \neq 0$
          \item $\forall u \in S \textrm{ tal que } u \neq 0$, $u$ es o bien una \emph{unidad}
                \footnote{un elemento con inversa. Es decir, un elemento $u$ tal que $\exists v \in S$ tal que
                          $uv = 1$}
         o tiene una representación única como producto de \emph{primos}
        \footnote{un elemento \emph{no} unitario $p$ tal que la expresión $p = qr$ se cumple sólo si o bien $q$ o $r$ es una unidad}.
        \end{itemize}
      \end{definicion}

      Un aspecto muy importante de los polinomios con coeficientes en $\mathbb{Z}$ es el siguiente:
    \begin{lema}[Polinomios sobre dominios de factorización única]
     Los polinomios con coeficientes en un dominio de factorización única
     forman a su vez un dominio de factorización única.
    \end{lema}

      Esto conduce a justificar la existencia y sentido de la habitual operación
      de cálculo del máximo común divisor sobre polinomios con coeficientes en un dominio de factorización
      única. 
      La especial operación de división de estos
      polinomios necesaria para implementar este método se expone a continuación.

    \paragraph{Pseudo-división de polinomios con \texttt{S} un dominio de factorización única}
    %TODO


  \subsection{Evaluación}\label{tipos:evaluacionPoly}
    Evaluar el valor de un polinomio $f(x)$ para un valor de $x = x_0$ dado es conceptualmente trivial:
    sustituir $x$ en la expresión del polinomio por $x_0$ y operar. Como suele ser habitual, la solución
    trivial dista de ser la óptima. De hecho, \cite{recipes} bromea con «cualquiera que evalúe de esta
    forma un polinomio será ejecutado de forma sumarísima». En esa obra se encuentra, en su sección 5.3, pág. 179
    un interesante análisis de la evaluación de polinomios.

    La conocida \emph{regla de Horner} evalúa un polinomio de grado $n$ tal como el dado en la expresión \eqref{poly} 
    en $n$ productos y $n$ sumas sin necesidad de almacenar resultados intermedios:
    \begin{equation}
      u(x_0) = u_0 + x_0(u_1 + x_0(u_2 + \cdots + x_0(u_n) \cdots )) \label{horner}
    \end{equation}

    Aunque este método resulta a primera viste inherentemente secuencial, en la sección \ref{parallel:evalPoly}
    se muestra de que forma es posible paralelizarlo.


  \subsection{Instancias concretas}
      %  Sobre Z
      %  Sobre R
      %  Sobre Z\_p 


\section{Matrices}\index{tipos!Matrices}\label{tipos:matrices}
%TODO
  \subsection{Instancias concretas}
    La clase modelando las matrices, \texttt{Matrix<T>}, comparte el carácter genérico
    de los polinomios, tanto en cuanto se toma a \texttt{T} como el tipo de sus elementos. 
    Sin embargo, por comodidad, se han implementado clases concretas representando las 
    particularizaciones más habituales. Se insiste en que esto es tan solo un atajo: la implementación
    de los diferentes métodos que operan sobre las matrices son genéricos, compartidos por todas las 
    instanciaciones del tipo de plantilla \texttt{T}. Las particularizaciones consideradas han sido:
    matrices sobre $\mathbb{Z}$, matrices sobre $\mathbb{R}$, matrices sobre $\mathbb{Z}_n$ y matrices sobre $\GF$. 
    En los dos últimos casos, la instanciación de estas matrices requiere que se le sea proporcionado al constructor
    en cuestión el valor de $n$ o el generador del cuerpo finito, respectivamente. 
    
  \subsection{Operaciones}
    En este punto se describen operaciones propias del \emph{anillo} formado por $\mathcal{M}_{n,n}$; esto es, 
    las matrices cuadradas.

    \subsubsection{Suma y resta}
    La suma (resp. resta) de matrices sobre un sistema \texttt{T} se define como la suma (resp. resta) 
    sobre \texttt{T} de los elementos situados en la misma fila y columna (para la suma): 
\[
\left( \begin{array}{cc}
      a_{11}+b_{11} & a_{12} + b_{12} \\
      a_{21}+b_{21} & a_{22} + b_{22}
\end{array} \right)
=
\left( \begin{array}{cc}
      a_{11} & a_{12} \\
      a_{21} & a_{22}
\end{array} \right)
+
\left( \begin{array}{cc}
      b_{11} & b_{12} \\
      b_{21} & b_{22}
\end{array} \right)
\]

    Es fácil observar que para cada elemento, la operación de suma es totalmente independiente
    de las demás, conformando una división en tareas \emph{embarazosamente paralela}\index{paralelo!embarazosamente --}.

    \subsubsection{Producto}
      La operación «estrella», ha sido objeto de mucho estudio con el fin de reducir su complejidad
      de $O(n^3)$, la del algoritmo fruto de la implementación directa de su definición. Sea 
      $\mathbf{A} \in \mathcal{M}_{m,n}$ y $\mathbf{B} \in \mathcal{M}_{n,k}$. Su producto resulta en una
      matriz $\mathbf{AB} \in \mathcal{M}_{m,k}$:
      \begin{equation}
        (\mathbf{AB})_{ij} = \sum_{r=1}^n a_{ir}b_{rj} = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots + a_{in}b_{nj}. \label{eq:matprod}
      \end{equation}
      para $1 \le i \le m$ y $1 \le j \le k$.

      Una de las estratégias que reducen la cota de complejidad cúbica fue ideada por Volker Strassen en 
      $1969$ (\cite{strassenorig}), siendo conocida habitualmente como el método de Strassen. 
      La mejora puede parecer pequeña, $O(n^{\lg_2{(7)}}) \approx O(n^{2.8})$, pero para tamaños de matriz suficientemente grandes,
      resulta ventajoso. Obtiene esta ventaja de sustituir operaciones de multiplicación por sumas --el mismo
      principio que utilizó Karatsuba para la multiplicación de enteros, \cite{miproyecto}\footnote{}--.
      Una variante
      de este método, presentada por Shmuel Winograd en $1980$ (\cite{strassenmult}), reduce el número de
      sumas del método original de Strassen, a la vez que maniene el número de multiplicaciones. 
      Esta es la versión que ha sido incorporadas a la biblioteca. 
      Además de estos métodos, el producto de matrices también ha sido parelelizado. Véase la sección \ref{par:matprod}.

      Una técnica habitual en la implementación del producto de matrices para bibliotecas matemáticas
      de alto rendimiento es la explotación de la jerarquía de memoria: la caché resulta mucho más rápida
      que la memoria convencional, por lo que si es posible dividir las matrices en bloques tales que todos
      los datos estén almacenados en la caché, el incremento de rendimiento es muy notable. Véase 
      \cite{bloques,emmerald,sciencematrix}. Sin embargo, no ha sido posible utilizar este enfoque en la 
      biblioteca debido a que no es posible estimar \textit{a priori} una cota del tamaño de las matrices, y
      por tanto tampoco de sus bloques: los elementos de las matrices poseen un tamaño arbitrario. Por contra,
      las bibliotecas para cálculo numérico habituales, utilizan tipos básicos --\texttt{float} o \texttt{double}--
      los cuales tienen un tamaño máximo preestablecido.

    \subsubsection{División}
      De la forma habitual, la división se define como el producto por la inversa. Dado que
      no toda matriz posee invesa, la división arrastra las mismas restricciones que la inversión.

    \subsubsection{Triangularización}
      %TODO
    \subsubsection{Resolución de sistemas de ecuaciones}
      %TODO
    \subsubsection{Inversión}
      Dada la categorización de $\mathcal{M}_{n,n}$ como anillo, la existencia de inversa para el operador  producto
      \emph{no} se garantiza. Sin embargo, es un resultado básico en álgebra que si 
      el rango de la matriz es igual al número de filas/columnas de ésta, dicha matriz es invertible. 
      Lo que habitualmente no se tiene en cuenta es si la operación de inversión resulta
      cerrada. Es decir, supóngase una matriz cuadrada sobre los enteros tal que su rango verifica ser
      igual a su número de filas/columnas. ¿Está todo elemento de su matriz inversa también en $\mathbb{Z}$?
      Es fácil comprobar que no:
\[
    A = 
\left( 
    \begin{array}{cc}
      1 & 2 \\
      3 & 4      
    \end{array} 
\right)
    ; \quad
    A^{-1} = 
\left( 
    \begin{array}{cc}
      -2  &    1 \\
      3/2 & -1/2      
    \end{array} 
\right)
\]
      
      Pese a que existen matrices sobre $\mathbb{Z}$ cuya inversa 
      tiene asimismo todos sus elementos en $\mathbb{Z}$, no se ha incorporado esta
      funcionalidad a la biblioteca\footnote{un estudio acerca de este tipo de matrices se
      realiza en \cite{intinv}}. 
      Esto se debe a que durante el proceso de inversión 
      implementado (véase sección \ref{impl:inversaMatrices}), se requiere la inversión 
      de los elementos de la matriz. Nótese que siempre es posible la conversión temporal de una 
      matriz de enteros a una matriz de reales, realizar su inversa y truncar los elementos de esta
      de vuelta al dominio de los enteros. 


    \subsubsection{Determinante}

      Pueden presentarse los determinantes como objetos matemáticos útiles en el análisis
      y resolución de sistemas de ecuaciones lineales: según la conocida regla de Cramer, 
      un sistema de ecuaciones lineales no homonogéneo posee solución única si y solo si 
      el determinante de la matriz asociada al sistema no distinto de cero.

      \begin{teorema}
        Sea $\mathcal{M}_{n,n}(\mathbb{K})$ el conjunto de todas las matrices sobre $\mathbb{K}$.
        Existe una única función 
        \[
         f: \mathcal{M}_{n,n}(\mathbb{K}) \longrightarrow \mathbb{K}
        \]
        tal que cumple las siguientes propiedades:
        \begin{itemize}
          \item $f$ es multilinear alternada respecto a las columnas: $f$ es lineal para cada columna 
          y cualquier permutación de las mismas provoca que su signo cambie.
          \item $f(I) = 1$, siendo $I$ la matriz identidad.
        \end{itemize}
      \end{teorema}

      No se demuestra aquí el teorema anterior, pero la llamada fórmula de Leibniz define tal función $f$:
      \begin{definicion}[Determinante (fórmula de Leibniz)]\label{def:determinante}
        Sea $A = \mathcal{M}_{n,n}$ una matriz cuadrada. 
        Es posible definir su  determinante como (fórmula de Leibniz):
        \begin{equation}
          \det(A) = \sum_{\sigma \in S_n} \sgn(\sigma) \prod_{i=1}^n A_{i,\sigma(i)}. \label{eq:determinante}
        \end{equation}
        con $S_n$ el grupo de permutaciones de $n$ elementos. El sumatorio
        contempla por tanto todas las permutaciones $\sigma$ de la secuencia $\{1,2,\ldots,n\}$.
        $\sgn(\sigma)$ se corresponde a la signatura de la permutación $\sigma$: $+1$ si
        $\sigma$ es una permutación par y $-1$ si es impar.
      \end{definicion}

      Nótese que el número de sumandos según la expresión \eqref{eq:determinante} es $n!$, 
      lo cual hace que no sea útil para el cálculo práctico del determinante. Detalles de los métodos
      utilizados en la biblioteca se muestran en la sección \ref{impl:determinante}
            
\section{Vectores}
%TODO

\section{Cuerpos finitos, $\GF$}\label{cuerposFinitos}
  
  \subsection{Elementos de un cuerpos finitos}
    


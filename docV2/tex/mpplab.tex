% CAPITULO SOBRE EL SERVIDOR XMLRPC Y EL CLIENTE EN PYTHON

\chapter{MPPLab: (una) ventana a la biblioteca}\label{chap:mpplab}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
        }
        \begin{flushright}
          \textbf{\textemdash .}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%


\section{Motivación}
  Una biblioteca como la que concierne a este trabajo no es
  algo fácil de apreciar a primera vista. Puede que, y ojala así sea,
  quien se aventurase en la lectura de su código o concediese el beneficio
  de la duda tras la lectura de la presente memoria, pudiera hacerse una
  idea -para bien o para mal- de su valor. Sin embargo, no se pretende poner
  un peso tal en el lector. Es más bien nuestra responsabilidad e intención el
  mostrarle al menos parte de su potencial, de una forma tanto atractiva
  como versátil y útil. Asimismo, sirve para poner en práctica destrezas y
  técnicas que no son fácilmente aplicables al desarrollo de una
  biblioteca.

  En términos más concretos, se busca el proporcionar una manera de
  interactuar con los métodos ofrecidos por la biblioteca sin necesidad de
  bajar al nivel del código. Si bien para una explotación exhaustiva de todos
  los mecanismos de la misma se hace necesario utilizarla realmente como
  una biblioteca -esto es, programando-, no es óbice para exponer aquellos
  que, aunque sólo en parte, muestren qué se ha desarrollado.

  Con este fin, e inspirados en conocidos paquetes para el trabajo en
  Matemáticas, tales como MatLab o Mathematica, se optó por un interfaz
  gráfico pero guiado por instrucciones textuales. Es más, las
  sentencias aceptadas por el cliente que se describe en el punto \ref{cliente}
  son un superconjunto del popular lenguaje de \textit{scripting}
  Python\footnote{\url{http://www.python.org}}. ¿Por qué se habla de
  «cliente»? Porque el diseño adoptado ha sido una arquitectura
  cliente/servidor como se expone a continuación. Esto aporta una serie de
  beneficios nada despreciables y brinda una vez más la oportunidad de
  ampliar el espectro de campos técnicos cubiertos en el presente trabajo.


\section{Desarrollo}
  
  \subsection{Arquitectura}\label{arquitectura}
  La especificación de una arquitectura depende siempre de los requisitos del sistema 
  a modelar. En el caso que nos ocupa, los requisitos pueden resumirse en:
  \begin{itemize}
    \item Posibilidad de ejecución de múltiples clientes de forma simultánea.
    \item Independencia entre clientes: cada cliente debe poder considerar ser el único
    utilizando el servidor (exceptuando cuestiones de rendimiento y/o perfilado).
  \end{itemize}

  En la figura \ref{fig:archClienteServidor} se representa el esquema adoptado.

  \begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth,keepaspectratio]{ClientServerArch} 
    \caption{Esquema de la arquitectura cliente/servidor}\label{fig:archClienteServidor}
  \end{figure}

  Como puede verse en dicha figura, se ha optado por utilizar el protocolo
  XML-RPC (\cite{xmlrpcspec}), por tratarse de un protocolo perfectamente
  indicado para la tarea a desempeñar: existen implementaciones del mismo en 
  prácticamente todos los lenguajes de programación mayoritarios, es sencillo aunque
  también potente, y muy versátil. Incluso, dado que descansa sobre el protocolo 
  HTTP, es posible el cifrado y/o compresión de los datos que maneja. 

  La capa que implementa los servicios XML-RPC se comunica directamente con los métodos
  de la biblioteca desarrollada, y ambas recurren a un almacén de datos en tiempo de ejecución
  para el intercambio de información (véase sección \ref{par:runtimeData}).


  \subsection{El servidor}\label{mpplab:server}
    Abarca la implementación de una capa cuya función es esperar a recibir peticiones
    XML-RPC de métodos exportados al cliente para posteriormente adaptarlas a las llamadas
    correspondientes a métodos de la biblioteca MPPLAS. Gestiona también todas las instancias
    de los datos creados en cada uno de los clientes. Estos puntos se desarrollan en mayor
    profundidad en las siguientes secciones.

    \paragraph{Características}\label{servidor:caracteristicas}
      \begin{itemize}
        \item Exporta métodos mediante XML-RPC (basado en la biblioteca \texttt{xmlrpc-c})
            \footnote{\url{http://xmlrpc-c.sourceforge.net/}}.
        \item Multihilo (basado en \texttt{pthreads}).
        \item Gestión dinámica de datos de los clientes en tiempo de ejecución.
        \item Mecanismos de recogida de basura (\textit{Garbage Collection}).
        \item Se soporta un subconjunto de los tipos soportados por la biblioteca. La
        correspondencia con estos, en cuanto a su definición, es prácticamente directa:
              \begin{description}
                \item[Z:] Enteros de longitud arbitraria. Se corresponde a la clase \texttt{mpplas::Z}.
                \item[Zn:]Enteros de modulares con módulo $n$ arbitrario. Se corresponde con \texttt{mpplas::Z\_n}.
                \item[R:] Reales de precisión arbitraria. Correspondencia con \texttt{mpplas::R}.
                \item[GF:]Cuerpos de Galois. Correspondencia con \texttt{mpplas::GF}.
                \item[GFx:]Elementos de un cuerpo de Galois. Correspondencia con \texttt{mpplas::GFx}.
                \item[MZ:] Matriz de enteros. Correspondencia con \texttt{mpplas::MatrixZ}.
                \item[MR:] Matriz de reales.  Correspondencia con \texttt{mpplas::MatrixR}.
                \item[MGFx:] Matriz sobre un cuerpo de Galois. Correspondencia con \texttt{mpplas::MatrixGFx}.
                \item[MZn:]  Matriz de enteros modulares. Correspondencia con \texttt{mpplas::MatrixZn}
              \end{description}
      \end{itemize}

      \subsubsection{Requisitos}
        Dado que el servidor exporta sus métodos mediante XMLRPC, se ha utilizado la implementación
        de este protocolo denominada «xmlrpc-c», disponible en \url{http://xmlrpc-c.sourceforge.net/}.

      \subsubsection{Utilización de XML-RPC}
        Por las razones expuestas anteriormente (véase \ref{arquitectura}), el servidor 
        pone a disposición de los clientes una serie de métodos mediante el protocolo 
        XML-RPC. Otra ventaja adicional del uso de esta tecnología son las capacidades de
        \emph{introspección} que ofrece\footnote{esto será de suma relevancia para la implementación
        del cliente, véase la sección \ref{boostrapping}}. Es decir, el propio servidor
        es capaz de dar información sobre qué métodos ofrece. El hecho de que el protocolo
        HTTP, sobre el que XML-RPC descansa, esté orientado a transacciones (véase \cite{stallings},
          pp. 676 y siguientes, para una descripción de este protocolo), siendo estas \emph{independientes}
        y no guardando ninguna información de estado en ellas, posibilita una gestión de errores más sencilla.
        Por ejemplo, si la comunicación entre cliente y servidor se ve interrumpida temporalmente, no es
        necesario restablecer ninguna conexión posteriormente, ya que cada una de las operaciones a
        nivel cliente-servidor es independiente de las demás.

      \subsubsection{Multihilo}
        Si se desea que varios clientes puedan operar de forma concurrente e 
        independiente, es necesario soportar de alguna forma la ejecución multihilo. 
        El protocolo XML-RPC descansa sobre el conocido HTTP, con lo que un servidor 
        XML-RPC no es más que un servidor HTTP ampliado: toda la gestión del tráfico 
        subyacente se realiza mediante este segundo protocolo. La ventaja que esto aporta
        es la existencia de numerosas soluciones para la implementación de un servidor
        HTTP, entre ellas las soluciones multihilo. Para este trabajo se ha utilizado
        el servidor HTTP incluido con la biblioteca \texttt{xmlrpc-c}, el cual incorpora
        soporte multihilo basado en la biblioteca \textit{pthreads}.

        Por tanto, y sin necesidad de implementar nada por nuestra parte, nuestro servidor
        manejará peticiones XML-RPC desde los clientes de forma simultánea e independiente.

  \subsubsection{Gestión dinámica de datos de los clientes en tiempo de ejecución.}\label{par:runtimeData}
    En el transcurso de una sesión de utilización del cliente, indudablemente se crearán
    instancias de los diferentes tipos de datos disponibles. Instancias que se corresponden,
    en el fondo, con datos de la biblioteca. Es necesario por tanto disponer de un mecanismo
    de almacenaje y recuperación eficaz y eficiente que permita trabajar cómodamente con
    los datos que el usuario vaya creando. Asimismo, habrá de cumplir también otros 
    requisitos impuestos por el cliente y la biblioteca, como son el ser \textit{thread-safe}
    y gestionar múltiples clientes de forma simultánea.

    \begin{figure}[h]
      \centering
      \includegraphics[width=0.95\textwidth,keepaspectratio]{runtimeData} 
      \caption{Esquema de la arquitectura cliente/servidor}\label{fig:runtimeData}
    \end{figure}

    El mecanismo implementado se representa en la figura \ref{fig:runtimeData}. En ésta
    se representa a \textit{grosso modo} el funcionamiento de este almacén 
    de datos dinámicos: a cada cliente conectado al servidor se le asigna un identificador
    de cliente (\texttt{clientId}) único. Mediante este identificador, se posibilita que 
    los clientes inserten y recuperen sus datos. El almacén de datos asigna un identificador
    de variable (\texttt{varId}) único (por cliente) tras cada inserción de un nuevo dato. 
    Es mediante este identificador de variable que el cliente puede posteriormente recuperar 
    el dato de forma unívoca.

    Todas las operaciones están, como se indicaba anteriormente, preparadas para soportar 
    la ejecución sobre múltiples hilos. Para esto, se utilizan rutinas de la biblioteca \textit{pthreads},
    ya que es este sistema mediante el que el servidor soporta la ejecución concurrente de varias
    peticiones. Por ejemplo:

\lstset{escapeinside={(*@}{@*)}}
\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,
  caption=Ejemplo de protección de sección crítica con pthreads]
  template<typename T>
  varId_t RuntimeData<T>::set(const clientId_t clientId, 
      const T& instance, 
      const std::string typeStr){
    pthread_mutex_lock( &_mutex ); (*@\label{alg:acquire}@*)
    const varId_t varId( _getAvailableVarId(clientId, typeStr) );
    _dataTable[clientId][varId] = instance;
    pthread_mutex_unlock( &_mutex ); (*@\label{alg:release}@*)
    return varId;
  }
\end{lstlisting}

  En la línea \ref{alg:acquire}, se asegura la sección crítica con un  \textit{candado} de \textit{pthreads}, que se libera
  al final de la misma, en la línea \ref{alg:release}.


    \subsubsection{Recogida de basura.} Se ha descrito cómo los datos, las instancias,
    son almacenadas en el servidor. Sin embargo, ¿cuándo se destruyen?
    Cada vez que se tiene un resultado de un cálculo, incluso temporales
    como la suma en una expresión del tipo $3*(4+5)$, una nueva
    instancia del tipo adecuado es creada y almacenada. Además, nada 
    impide al cliente dejar que el resultado se pierda: no es necesario 
    asignar siempre un resultado a una variable. 
    
    Dándole la vuelta a la cuestión: ¿qué \emph{sí} debe conservarse, al
    menos hasta la desconexión del cliente? Aquellas instancias
    asociadas a una variable. Es decir, no debe darse el caso de una
    variable cuyos datos, los datos a los que apunta, no existan. Dado
    que la gestión de las variables corre a cuenta del cliente, el
    servidor recibe tan solo una lista de los identificadores de
    variables a conservar. El resto de identificadores y sus instancias
    asociadas serán eliminados y los recursos que utilizasen,
    liberados. Esto se corresponde con una de las formas más sencillas
    de recolección de basura.
    Afortunadamente, cubre nuestras necesidades satisfactoriamente. 

    El campo de los recolectores de basura es amplio y complejo, y su
    bibliografía abundante. Posiblemente los entornos de ejecución más
    populares que utilizan esta técnica son las diferentes implementaciones 
    del \textit{Java Runtime Environment}. 
    En el momento de redactar estas líneas, la inclusión de recolectores
    de basura está incluida dentro del borrador de la nueva revisión del
    lenguaje C++,
    C++0x\footnote{\url{http://www.open-std.org/jtc1/sc22/wg21/}}.
      

  \subsection{\emph{Un} cliente}\label{cliente}
    El énfasis en el artículo indeterminado «un» en el título no es
    casual: dada la versatilidad del protocolo XML-RPC, servidor y
    cliente están completamente desacoplados. Por tanto, la presente
    implementación es tan solo una de las posibles que podrían
    utilizarse para «dialogar» con el servidor. 

    En la figura \ref{fig:client} se muestra la estructura del cliente.
    \begin{figure}[h]
      \centering
      \includegraphics[width=0.85\textwidth,keepaspectratio]{estructuraCliente} 
      \caption{Estructura del cliente MPPLab}\label{fig:client}
    \end{figure}


    \paragraph{Características}
      \begin{itemize}
        \item \textit{Bootstrapping}: inspección de métodos disponibles
              en el servidor, realizando \emph{el propio cliente} la
              escritura e interpretación del código necesario para su 
              utilización.
        \item Fácilmente configurable.
        \item Soporte para el trazado de gráficas.
        \item Multiplataforma.
        \item Actualizaciones automáticas.
        \item Multihilo, pudiendo de ser explotado explícitamente por el usuario.
        \item Basado en el lenguaje Python: ofrece todas las
        funcionalidades de este lenguaje.
      \end{itemize}

    \subsubsection{Requisitos y ejecución}
      Para la correcta ejecución del cliente son necesarios una serie de paquetes adicionales:
      \begin{description}
        \item[WxPython.] Proporciona un vínculo (\textit{binding}) con el API gráfico WxWidgets
        \footnote{\url{http://www.wxwidgets.org/}}, permitiendo presentar el interfaz del cliente
        de forma gráfica. Disponible en \url{http://www.wxpython.org/}.
        \item[matplotlib y numPy.] Paquetes necesarios para el trazado de gráficas. Disponibles en
        \url{http://matplotlib.sourceforge.net/} y \url{http://numpy.scipy.org/} respectivamente. 
      \end{description}


    \subsubsection{\textit{Bootstrapping} y autoescritura.}\label{boostrapping}
      Una de las características más destacables de este cliente es su habilidad para
      «escribirse a sí mismo». Esto es posible debido fundamentalmente a dos razones:
      la capacidad de Python de interpretar código en tiempo de ejecución y los mecanismos
      de introspección que el servidor XML-RPC ofrece.

      ¿A qué nos estamos refiriendo cuando hablamos de «autoescritura»? A la capacidad
      de incorporar en el cliente métodos ofrecidos por el servidor de forma automática en tiempo
      de ejecución, y por tanto sin necesidad de modificar el cliente. 

      Por brevedad, no se incluye aquí el código del cliente --el cual se puede consultar en el
      fichero \texttt{Client.py}, función \texttt{initializeClient}. De todos modos, se 
      presenta una versión en pseudocódigo en el algorimo \ref{alg:bootstrapping}.
      
       \begin{algorithm}
        \caption{Mecanismo de \textit{bootstrapping}}\label{alg:bootstrapping}
        \begin{algorithmic}[1]
          \State $metodosDisponibles \gets $ \textsc{MétodosExportadosPorServidorXMLRPC()}
          \ForAll{$metodo \in metodosDisponibles$}
            \State \textsc{DeclararMétodoEnCliente($metodo$)}
          \EndFor
        \end{algorithmic}
      \end{algorithm}

      Detrás de la aparente simplicidad de esta representación en pseudocódigo se esconden
      varios aspectos complejos en la práctica. Concretamente, se aprovecha la homogeneidad
      en la invocación de los métodos del servidor para extraer el «factor común» a la declaración
      de los mismos en el cliente. Este «factor común» se convierte en una plantilla de texto 
      genérica, que es instanciada con el nombre y los datos concretos cada método, siendo
      posteriormente incorporada por el cliente a sí mismo mediante \emph{en tiempo de ejecución}, 
      gracias a la sentencia \texttt{exec} de Python. Es por eso que se habla de
      \textit{bootstrapping}, porque el propio cliente es capaz de incorporar a
      sí mismo el código encargado de poner a disposición las funciones de la biblioteca
      exportadas por el servidor.
      
      Dos de los problemas concretos más importantes se analizan a continuación.
      \paragraph{¿Cómo manejar el paso de parámetros de forma genérica?}
        No todos los métodos requieren el mismo número de parametros. Algunos siquiera
        requieren parametros en absoluto. Sin embargo todos los métodos se están declarando,
        tal y como se ha descrito anteriormente, de la misma forma genérica. ¿Cómo
        mantener este carácter genérico a la vez que se permite la diversidad en 
        el número de parámetros de los métodos? Una vez más Python aporta la solución 
        desde la base, facilitando el paso de un número arbitrario de argumentos  
        (\cite{pythonref}\footnote{sección 5.3.4}):

        \begin{quote}
        If there are more positional arguments than there are formal parameter
        slots, a TypeError exception is raised, unless a formal parameter using
        the syntax ``*identifier'' is present; in this case, that formal
        parameter receives a tuple containing the excess positional arguments
        (or an empty tuple if there were no excess positional arguments).
        \end{quote}

        Por tanto, si cada método creado mediante \textit{bootstrapping} se
        declara utilizando esta sintaxis, podrá recibir un número arbitrario de 
        tantos argumentos.
        
      \paragraph{¿Cómo manejar los resultados de los métodos?}
        De nuevo, la declaración genérica de los métodos priva de toda 
        consideración particular. El problema ahora es cómo interpretar los datos
        devueltos por los diferentes métodos. Es más, si el dato devuelto es un 
        tipo de los expustos anteriormente en el punto \ref{servidor:caracteristicas},
        lo devuelto será su identificador dentro de la tabla de datos en tiempo 
        de ejecución que gestiona el servidor. Por supuesto, esto ha de ser transparente
        al usuario. Aquí se desvela la razón de anteponer el tipo de dato al identificador.
        De esta manera es posible determinar el tipo de dato apuntado por el identificador,
        e instanciarlo convenientemente.


    \subsubsection{Fácilmente configurable.}
    Varios aspectos del cliente son configurables por el usuario. Por ejemplo, la dirección y puerto en el sistema donde se está
    ejecutando el servidor, si se debe comprobar si existen versiones más recientes en dicho servidor, la frecuencia
    de ejecución del recolector de basura, etc. En el listado \ref{lst:ejConfig} se muestra el contenido del fichero de configuración
    utilizado para conectarse al sistema de desarrollo principal:

\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=Ejemplo de configuración,label=lst:ejConfig] 
[CLIENT]
transport = http
host = 156.35.170.162
port = 1729
path = /Client.py
checkforupdates = true
GCThreshold = 20

[SERVER]
host = 156.35.170.162
port = 1729
transport = http
path =
\end{lstlisting}

  El procesado de estos ficheros de configuración corre a cargo de la clase \texttt{Configuration}, contenida en el
  fichero \texttt{Configuration.py}. Se trata de una implementación propia basada en el módulo de la librería estandar
  de Python \texttt{ConfigParser}\footnote{\cite{pythonlib}, sección 9,2}. 

    \subsubsection{Trazado de gráficas}
      Mediante la integración de las rutinas ofrecidas por el paquete \texttt{matplotlib}, resulta
      posible el trazado de gráficas según la sintaxis del conocido paquete de cálculo simbólico
      MatLab. En la sección \ref{mpplab:ejs} se ilustra con ejemplos esta funcionalidad. 

    \subsubsection{Actualización automática.}
      Característica motivada por el deseo de agilizar el ciclo desarrollo-prueba-desarrollo-prueba
      por parte del autor y sus supervisores, se incorporó un mecanismo de actualización automática.

      Su funcionamiento se basa en comparar el fichero que contiene el grueso de la implementación 
      del cliente, \texttt{Client.py}, en el sistema local con otra versión, presuntamente la más
      reciente, almacenada en el servidor. Esta comparación utiliza una \emph{función resumen} 
      --en concreto MD5-- para evitar comparar íntegramente este fichero. Si se 
      detecta una discrepancia en los resultados de esta función resumen, se asume que es debido a
      que la implementación almacenada en el servidor ha sido sustituida con una versión más reciente.
      En tal caso, se informa al usuario, y si éste desea actualizarse, 
      se descarga la versión disponible en el servidor, que sustituye a la local. Tras reiniciar
      el cliente, se estará utilizando la versión actualizada.
      
    \subsubsection{Multihilo.}
      Esto es un reflejo de que el servidor sea también multihilo. La
      explotación de esta característica se expone en la sección \ref{runInParallel}.

      Internamente, el cliente se apoya en una abstracción, dada por la clase \texttt{ThreadRunner} 
      tal como aparece en la figura \ref{fig:client}. Esta clase hereda de la clase \texttt{thread.Thread}
      de Python, y es la encargada de gestionar la ejecución de los cálculos lanzados concurrentemente
      desde el cliente, asegurando la correcta gestión de las secciones críticas, tales como la 
      recolección de resultados desde los distintos hilos. 
      
    \subsubsection{Modelando el servidor}
      Como se puede observar en la figura \ref{fig:client}, existe una capa encargada
      de aislar al cliente de los entresijos de la comunicación con el servidor. Dicha
      capa se encuentra implementada en el fichero  \texttt{RPCServer.py} y hace
      uso de la técnica de los mixins (sección \ref{tech:mixins}) y el patrón singleton (sección \ref{sec:singleton})
      en el contexto del lenguaje Python. 


    El resto de las características, ser multiplataforma y un
    superconjunto de Python, derivan de la base utilizada: la
    biblioteca WxPython\footnote{\url{http://www.wxpython.org/}}.
    %TODO: completar un poco más.
    Las ventajas de utilizar Python como base son numerosas. Podría 
    parecer que complicase la utilización del cliente, por
    tener que lidiar con este lenguaje; por contra, la sencilla e
    intuitiva sintaxis del mismo minimiza este efecto. De haber
    implementado un lenguaje propio para el cliente, su sintaxis no habría 
    podido ser mucho más simple, y casi con toda seguridad mucho menos
    potente. 

      


  \subsection{Pequeño manual de utilización}
      \paragraph{Consideraciones generales}
        Ciertos aspectos pueden chocar a primera vista, o ser considerados como errores, aunque en ocasiones
        su uso pueda resultar ventajoso. Sirva de ejemplo, la copia de variables:
        tal como se ha expuesto en la sección \ref{arquitectura}, el cliente trabaja con \emph{referencias} a las instancias
        de los datos almacenados en el servidor. Cuando en el interfaz cliente, se ejecuta una asignación
        \texttt{var1 = var2}, lo que se asigna a \texttt{var1} es en realidad tal referencia, con lo cual \texttt{var1}
        y \texttt{var2} harían referencia a la misma variable. Cualquier modificación \textit{in situ} del dato 
        apuntado sería visible a través tanto de \texttt{var1} como de \texttt{var2}.

        ¿Cómo evitar este comportamiento? Es habitual, y necesario en muchas ocasiones, el querer realizar 
        copias \emph{independientes} de los datos. El modo de lograrlo es invocando \emph{el constructor} del tipo
        a copiar. Por ejemplo:

\begin{verbatim}
>>> var1 = MZ("[1 2; 3 4]")
>>> print var1
[  1  2 ]
[  3  4 ]

>>> var2 = var1
>>> print var2
[  1  2 ]
[  3  4 ]

>>> var1[(1,0)] = Z(321)
>>> print var1
[    1  2 ]
[  321  4 ]

>>> print var2
[    1  2 ]
[  321  4 ]

>>> var3 = MZ(var1)
>>> print var3
[    1  2 ]
[  321  4 ]

>>> var1[(1,0)] = Z(456)
>>> print var1
[    1  2 ]
[  456  4 ]

>>> print var3
[    1  2 ]
[  321  4 ]
\end{verbatim}

      En el ejemplo anterior, \texttt{var3} es creada mediante una llamada al constructor \texttt{MZ}, con lo que
      se crea una \emph{nueva instancia} de una matriz sobre los enteros, inicializada con los valores de \texttt{var1}.

    \subsubsection{Tipos disponibles}
       \paragraph{Z} Representa un entero de precisión arbitraria. Para crear este tipo de dato, basta con 
       invocar a su constructor de la siguiente manera: 
\begin{verbatim}
>>> unEntero = Z('35872687327373')
\end{verbatim}
        Las operaciones sobre enteros son las básicas:
\begin{verbatim}
>>> otroEntero = getRandomZ(100)
>>> print unEntero, otroEntero
35872687327373 621786157705605499575785094237
>>> unEntero + otroEntero
621786157705605535448472421610
>>> unEntero - otroEntero
-621786157705605463703097766864
>>> unEntero * otroEntero
22305140419861824038317960677452898474649401
>>> unEntero / otroEntero
0
>>> unEntero % otroEntero
35872687327373
>>> pow(unEntero, otroEntero, Z(11234)) #exponenciación modular
1357
\end{verbatim}


       \paragraph{Zn} Representa un entero modular de precisión arbitraria. El constructor en este caso require
       de la presencia del módulo $n$. Asimismo, si dicho $n$ es primo, es posible utilizar métodos propios
       del trabajo sobre un cuerpo, tal como la inversión:
\begin{verbatim}
>>> z = Zn("1233", Z("19"))
>>> print z
17
>>> z.getInverse()
9
>>> z * z.getInverse()
1
\end{verbatim}

       \paragraph{R} Representa un real de precisión arbitraria. Su utilización es muy similar a la del tipo de dato para 
       enteros, con la salvedad de poder controlar tanto el número de bits utilizados para manejar su precisión interna
       como cuantos dígitos en base $10$ son mostrados:
\begin{verbatim}
>>> unReal = R('1.78346873235353')
>>> R.setOutputPrecision(3)
>>> print unReal
1.783
>>> R.setInnerPrecision(2000)
>>> unReal = R('1.78346873235353')
>>> R.setOutputPrecision(0) #usar máxima precisión
>>> print unReal
1.783468732353530000(...)000
\end{verbatim}
       \paragraph{GF} Representa un Cuerpo Finito, a modo de generador de elementos del mismo. 
       Es posible obtener información acerca del cuerpo mediante el método \texttt{getProperties()}. Los elementos
       del cuerpo se obtienen mediante el método \texttt{getElement()}.
       En el siguiente párrafo se incluyen ejemplos, junto con los correspondientes a \texttt{GFx}.

       \paragraph{GFx} Representa un elemento de un Cuerpo Finito.
       Al igual que en el caso anterior, y por comodidad, se puede obtener información acerca del cuerpo finito
       al que pertenece el elemento mediante el método \texttt{getProperties()}. Asimismo, otros métodos disponibles
       en este tipo de dato son: 
       \begin{description}
        \item[\texttt{getInverse()}] Devuelve la inversa del elemento sobre el que se aplica el método.
        \item[\texttt{getPBRString()}] Devuelve una cadena de caracteres representado el polinomio correspondiente
        al elemento sobre el que se aplica. Las siglas «PBR» se corresponden al término «Polynomial Basis Representation».
        \item[\texttt{setValue(z)}] Asigna al elemento sobre el que se aplica el método el valor del entero $z$ argumento
        dentro del cuerpo finito.
        \end{description}

        El siguiente ejemplo ilustra los puntos recién descritos:
\begin{verbatim}
>>> gf = GF(p=2, n=4, usePrimitive=True)
>>> gf.getProperties()
{'characteristic': '2', 'modulus': ' +1*x^4 +1*x^3 +1', 
  'isModulusPrimitive': True, 'order': '16', 'degree': 4}
>>> e = gf.getElement(123)
>>> print e
11
>>> print e.getPBRString()
 +1*x^3 +1*x^1 +1
>>> print e.getInverse()
10
>>> print e.getInverse() * e
1
>>> e.setValue(65)
[(1, 0)]
>>> print e
1
>>> print e.getInverse()
1
\end{verbatim}

       \paragraph{MZ} Representa una matriz sobre el anillo de los enteros. Existen ciertos aspectos comunes
       a los tipos matriciales, tales como el acceso a los elementos, la información sobre las dimensiones 
       y la transposición.
       Sin perdida de generalidad, véase el siguiente ejemplo para una matriz sobre los enteros:
\begin{verbatim}
>>> mat = MZ("[1231 47323213; -383485 124224]")
>>> print mat
[     1231  47323213 ]
[  -383485    124224 ]

>>> print mat[(0,0)]
1231
>>> mat[(0,0)] = Z('0')
>>> print mat
[        0  47323213 ]
[  -383485    124224 ]
>>> m = MZ("[ 1 2 3 ; 4 5 6 ; 7 8 9]")
>>> print m.getTranspose()
[  1  4  7 ]
[  2  5  8 ]
[  3  6  9 ]
\end{verbatim}

\subparagraph{Obtención a submatrices.}
 La operación de acceso a una submatriz opera de la siguiente manera:
  \begin{description}
    \item[\texttt{getSubMatrix(rows=(ini,paso,fin), cols=(ini,paso,fin))}] Devuelve la submatriz formada por 
    las filas/columnas especificadas por \texttt{ini}, \texttt{paso} y \texttt{fin}. Ambas filas/columnas
    del interval son \emph{incluidas}. 
    
    Es posible omitir estos parámetros, pero «manteniendo el orden»; es decir, es posible omitir \texttt{fin} y \texttt{paso}, pero no
    es posible omitir \texttt{paso} y especificar \texttt{fin}. Los valores dados a estos tres parametros por omisión son $0$, $1$ y 
    «hasta el final», respectivamente.
  \end{description}
\begin{verbatim}
 >>> print m
[   0   1   2   3   4 ]
[   5   6   7   8   9 ]
[  10  11  12  13  14 ]
[  15  16  17  18  19 ]
[  20  21  22  23  24 ]

 >>> print m.getSubMatrix()
[   0   1   2   3   4 ]
[   5   6   7   8   9 ]
[  10  11  12  13  14 ]
[  15  16  17  18  19 ]
[  20  21  22  23  24 ]

#tres primeras filas, y de la primera a la quinta columna de forma
#alternada
 >>> print m.getSubMatrix((0,2),(0,2,4))
[   0   2   4 ]
[  10  12  14 ]
[  20  22  24 ]

#tres primeras filas y cinco primeras columnas
 >>> print m.getSubMatrix((0,2),(0,1,4))
[   0   1   2   3   4 ]
[  10  11  12  13  14 ]
[  20  21  22  23  24 ]

# indicando solo donde empezar
 >>> print m.getSubMatrix((2),(4))
[  14 ]
[  19 ]
[  24 ]

 >>> print m.getSubMatrix((1,1,3),(1,1,3))
[   6   7   8 ]
[  11  12  13 ]
[  16  17  18 ]
\end{verbatim}

\subparagraph{Construcción dadas las dimensiones.}
       También es posible crear una matriz especificando sus dimensiones. Será inicializada con ceros:
\begin{verbatim}
>>> mat = MZ(n=3,m=5)
>>> print mat
[  0  0  0  0  0 ]
[  0  0  0  0  0 ]
[  0  0  0  0  0 ]

>>> (n,m) = mat.getDimensions()
>>> print n,m
3 5
>>> for i in range(n):
...     for j in range(m):
...         mat[(i,j)] = getRandomZ(30)
...     
>>> print mat
[  1212240068  2403666701  2954393915  3377825059  4222186755 ]
[  3987194506   831735211  1205127533  1202186320  1521499748 ]
[  3996584786    46050137  1380962956  3307867696  3238229487 ]
\end{verbatim}

\subparagraph{Uniendo matrices}
Así como es posible seleccionar submatrices de una matriz dada, resulta también útil
el poder crear una nueva matriz a partir de la concatenación, por filas o columnas, de otras
matrices. En este caso sólo se consideran filas o columnas contiguas. De todas formas, siempre
resulta posible, mediante la adecuada combinación de las operaciones de concatenación, de replicar
este comportamiento para filas o columnas no contiguas. Véanse algunos ejemplos:
\begin{verbatim}
>>> m1 = MZ("[1 2; 3 4]")
>>> m2 = MZ("[8 9 ;5 2; 5 7; 2 1]")
>>> print m1
[  1  2 ]
[  3  4 ]

>>> print m2
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]

>>> print m1.appendByColumns(m2)
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]

>>> print m1
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]
\end{verbatim}
Como puede verse, la matriz se modifica.Si no se desea esto:
\begin{verbatim}
>>> print m1
[  1  2 ]
[  3  4 ]

>>> print MZ(m1).appendByColumns(m2)
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]

>>> m1 = MZ("[1 2; 3 4]")
>>> print m1.appendByColumns(m2).appendByColumns(m1)
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]
\end{verbatim}
Asimismo, es posible encadenar las operaciones. Nótese que este tipo de
sentencias se evaluan de derecha a izquierda:
\begin{verbatim}
>>> m1 = MZ("[1 2; 3 4]")
>>> print m1.appendByColumns(m2).appendByColumns(m1)
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]
[  1  2 ]
[  3  4 ]
[  8  9 ]
[  5  2 ]
[  5  7 ]
[  2  1 ]

\end{verbatim}
El funcionamiento del método \texttt{appendByRows} es análogo pero orientado
a filas.

       \paragraph{MGFx} Representa una matriz sobre elementos de un cuerpo finito dado. La particularidad de este tipo de 
       matrices radica en que llevan asociado un cuerpo finito, al cual pertenecen los elementos anteriormente referidos. 
       De otro modo, podría darse el caso de que un elemento
       de la matriz fuese miembro de un cuerpo finito distinto al de los demás, resultando en una estructura carente
       de todo sentido matemático. Se encuentran disponibles algunos métodos no disponibles para matrices de enteros: 
       \begin{description}
        \item[\texttt{getInverse()}] Devuelve la matriz inversa de la matriz sobre la que se aplica el método.
        \item[\texttt{getTranspose()}] Devuelve la transpuesta de la matriz sobre la que se aplica el método.
        \item[\texttt{solveFor(b)}] Espera un vector columna $b$ y devuelve el vector columna $y$ tal que $My = b$, 
        siendo $M$ la matriz sobre la que se aplica el método.
        \end{description}

\begin{verbatim}
>>> gf = GF(p=2, n=5)
>>> mat = MGFx("[34 56 421; 31 0 -24; 35 1 2]", gf=gf)
>>> print mat
[   2  24  5 ]
[  31   0  8 ]
[   3   1  2 ]

>>> print mat.getTranspose()
[   2  31  3 ]
[  24   0  1 ]
[   5   8  2 ]

>>> print mat.getInverse()
[  16  27  26 ]
[  18  22   4 ]
[  17  10   2 ]

>>> print mat.getInverse() * mat
[  1  0  0 ]
[  0  1  0 ]
[  0  0  1 ]

>>> b = MGFx("[1; 2;3]",gf=gf)
>>> y = mat.solveFor(b)
>>> y
[ 8 ; 29 ; 3  ]
>>> mat * y
[ 1 ; 2 ; 3  ]
>>> b
[ 1 ; 2 ; 3  ]
\end{verbatim}

       \paragraph{MR} Representa una matriz sobre el cuerpo de los reales. Los ejemplos anteriores para matrices
       sobre enteros son directamente aplicables a matrices sobre reales, con la salvedad, claro esta, de que 
       allí donde se utilice un tipo entero, habría de utilizarse un real. 
       El repertorio se completa con los tres métodos anteriormente descritos para matrices sobre 
       cuerpos finitos. Su funcionamiento es análogo para matrices sobre reales.

       \paragraph{MZn} Matriz sobre enteros modulares $\mathbb{Z}_n$. El módulo $n$ es arbitrario. Si 
       se utiliza un $n$ primo, será posible utilizar métodos propios de matrices sobre cuerpos, tales como
       la inversión o la resolución de sistemas de ecuaciones. Al construir la matriz es necesario proporcionar
       el módulo $n$. Ejemplos:

\begin{verbatim}
>>> print MZn("[1 2 3; 341 352 9; 0 31 1]", mod=Z("7"))
[  1  2  3 ]
[  5  2  2 ]
[  0  3  1 ]      

>>> a =  MZn("[1 2 3; 341 352 9; 0 31 1]", mod=Z("7"))
>>> a*a.getInverse()
[ 1 0 0 ; 0 1 0 ; 0 0 1  ]
>>> b =  MZn("[1 2 3; 341 352 9; 0 31 1]", mod=Z("8"))
>>> print b
[  1  2  3 ]
[  5  0  1 ]
[  0  7  1 ]
\end{verbatim}

Si se trata de invertir una matriz sobre $\mathbb{Z}_n$ con $n$ \emph{no} primo, se producirá una excepción:
\begin{verbatim}
>>> b.getInverse()
Traceback (most recent call last):
  File "<input>", line 1, in <module>
  File "/home/dgquintas/libmpplas/trunk/demos/client/Client.py", 
    line 975, in getInverse
    return _mz_nInv(self)
  File "<string>", line 18, in _mz_nInv
  File "xmlrpclib.py", line 1147, in __call__
    return self.__send(self.__name, args)
  File "xmlrpclib.py", line 1437, in __request
    verbose=self.__verbose
  File "xmlrpclib.py", line 1201, in request
    return self._parse_response(h.getfile(), sock)
  File "xmlrpclib.py", line 1340, in _parse_response
    return u.close()
  File "xmlrpclib.py", line 787, in close
    raise Fault(**self._stack[0])
Fault: <Fault 0: 'Invalid Argument error: Tried to invert a 
non-invertible element;
\end{verbatim}




    
    \subsubsection{Funciones disponibles}\label{funciones} 
    Mediante la instrucción \texttt{listFuncs()} se obtiene una lista de las funciones específicas exportadas 
    desde la biblioteca desarrollada. Existen más métodos exportados, pero se encuentran ocultos en la implementación
    de los diferentes tipos de datos (por ejemplo, la inversión de matrices). El cliente incorpora un sistema de 
    ayuda contextual dinámica: la documentación correspondiente a cada función es mostrada cuando el nombre de una de ellas
    es introducido. Asimismo, una lista exhaustiva de las funciones disponibles y su descripción puede obtenerse mediante 
    la instrucción \texttt{helpFuncs()}.

    \paragraph{Teorema chino de los restos}
    Esta función, cuyo prototipo es \texttt{crt( listaCongruencias, listaModulos )}\footnote{«CRT» es la abreviatura
      habitual de este método en la bibliografía en inglés: \textit{Chinese Remainder Theorem}} devuelve un entero
      congruente con cada entero de \texttt{listaCongruencias} modulo el entero correspondiente a la misma posición de 
      \texttt{listaModulos}. 

\begin{verbatim}
>>> crt([Z(2),Z(3),Z(1)],[Z(3),Z(4),Z(5)])
11
\end{verbatim}

    En el anterior ejemplo $11$ verifica $ 11 \equiv 2 \pmod{3} $,  $11 \equiv 3 \pmod{4}$   y  $11 \equiv 1 \pmod{5}$.

    \paragraph{Factorización de enteros}
      La función \texttt{factorize} devuelve una lista con los enteros correspondientes a la factorización del
      entero pasado como argumento. Si alguno de los factores se repite, aparecerá dos veces en dicha lista:

\begin{verbatim}
>>> n = getRandomZ(60)
>>> print n
7933811805625598031
>>> factorize(n)
['3', '4111', '643299424764907']
\end{verbatim}

    \paragraph{Máximo común divisor}
    Las funciones \texttt{gcd}\footnote{«GCD» es la abreviatura
      habitual de este método en la bibliografía en inglés: \textit{Greatest Common Divisor}} 
      y \texttt{gcdext} se corresponden, respectivamente, con el cálculo de únicamente
    el máximo común divisor de dos enteros dados y los coeficientes $s$ y $t$ verificando 
    $gcd(a,b) = a\cdot s + b \cdot t$. Estos coeficientes son también conocidos como los coeficientes de 
    Bézout.

\begin{verbatim}
>>> (a,b) = (getRandomZ(32), getRandomZ(48))
>>> gcd(a,b)
1
>>> gcdext(a,b)
['1', '172127432233870', '-148890431']
>>> (d,s,t) = gcdext(a,b)
>>> a*Z(s) + b*Z(t)
1
\end{verbatim}


    \paragraph{Números primos}
    Se describen a continuación los métodos disponibles relacionados con los números primos
    \begin{description}
    \item[\texttt{getPrime(n)}] Devuelve un primo de al menos $n$ bits.
    \item[\texttt{getPrimeBounded(z)}] Devuelve un primo menor o igual que el entero $z$.
    \item[\texttt{getStrongPrime(n)}] Devuelve un primo criptográficamente seguro
      \footnote{véase \cite{miproyecto}, sección 6.6.2, pág. 86, para 
      la definición de primo criptográficamente seguro} de $n$ bits.
    \item[\texttt{isPrime(z)}] Comprueba si el entero $z$ dado es primo.
    \end{description}

\begin{verbatim}
>>> p = getPrime(123)
>>> print p
328458830735466518884555062997960854541
>>> isPrime(p)
True
>>> [getPrimeBounded(Z(i)) for i in range(10,50,5)]
[11, 17, 23, 29, 31, 37, 41, 47]
>>> getStrongPrime(32)
229147538131
>>> isPrime(Z(229147538131))
True
\end{verbatim}


    \paragraph{Números (pseudo)aleatorios}
    Se describen a continuación los métodos disponibles relacionados con los números (pseudo)aleatorios

    \begin{description}
    \item[\texttt{getRandomZ(n)}] Devuelve un entero pseudoaleatorio de $n$ bits. 
    \item[\texttt{getRandomZLessThan(z)}] Devuelve un entero pseudoaleatorio menor que el entero $z$.
    \item[\texttt{getSecureRandomZ(n)}] Devuelve un entero aleatorio (basado en entropía real) criptográficamente seguro de bits $n$.

    \end{description}


    \paragraph{Mínimo común múltiplo}
    La función \texttt{lcm()}\footnote{«LCM» es la abreviatura
      habitual de este método en la bibliografía en inglés: \textit{Least Common Multiple}}
      devuelve el mínimo común múltiplo de sus dos argumentos enteros.

   \paragraph{Miscelanea}
   \begin{description}
   \item[\texttt{jacobiSymbol(a,n)}]: Devuelve el símbolo de Jacobi para los dos enteros pasados como argumentos.
   \item[\texttt{legendreSymbol(a,p)}]: Devuelve el símbolo de Legendre para los dos enteros pasados como argumentos.
   \item[\texttt{modExp(base, exp, mod)}]: Realiza la exponenciación modular del primer entero por el segundo, reducidos módulo el tercero.
   \item[\texttt{modInverse(base, exp)}]: Invierte el primer entero pasado como argumento módulo el segundo.

   \end{description}
\begin{verbatim}
>>> jacobiSymbol(Z('123'),Z('35'))
-1
>>> n = getRandomZ(100); p = getPrime(32)
>>> print n,p
1243068081088301991839443832709 1575940489
>>> legendreSymbol(n,p)
1
>>> modExp(Z(123),Z(456), getPrime(32))
2019702949
>>> p = getPrime(32)
>>> modInverse(Z(123), p)
194977768
>>> Z(123)*modInverse(Z(123), p) % p
1
\end{verbatim}



    \paragraph{Información del sistema servidor}
    La función \texttt{getSystemInfo} devuelve abundante información referente al sistema sobre
    el cual se está ejecutando el servidor. Esto es útil por ejemplo para saber cuantos hilos físicos
    es posible ejecutar, o si el sistema tiene soporte multihilo, de perfilado, etc.
    La función devuelve un tipo diccionario de Python, por lo que es sencillo consultar el valor de sólo
    alguno de los datos:
\begin{verbatim}
>>> import pprint
>>> pprint.pprint(getSystemInfo())
{'BuildDate': 'Nov 15 2007',
 'BuildTime': '21:48:56',
 'CPUInfo': {'ArchName': 'x86',
             'CacheL1Size': 32768,
             'CacheL2Size': 1048576,
             'CacheL3Size': 0,
             'DigitBitWidth': 32,
             'ModelName': 'Intel(R) Pentium(R) M processor 1500MHz',
             'SIMDCapabilities': ['MMX', 'SSE', 'SSE2']},
 'CompilerCmd': 'g++ -o -c -pipe -O0 -ggdb3 -m32 -fPIC -msse2 -DUSESIMD_sse2 
                -DARCHBITS=32 -DARCH_x86',
 'MaxNumberOfThreads': 1,
 'OpenMPEnabled': False,
 'OptimizationLevel': 0,
 'ProfilingEnabled': True,
 'ReleaseVersion': False,
 'RevisionNumber': 598,
 'SIMDKernel': 'sse2'}

>>> getSystemInfo()['MaxNumberOfThreads']
1
\end{verbatim}


    \subsubsection{Ejecución en paralelo}\label{runInParallel}
      Mediante la función \texttt{runInParallel}, es posible ejecutar un número arbitrario de operaciones
      en el cliente de forma simultánea, con un grado \emph{lógico} de paralelismo también arbitrario.
      Con «lógico», se quiere resaltar que es posible lanzar simultáneamente tantos hilos del cliente como se
      desee, pero el grado \emph{físico} de paralelismo siempre vendrá fijado por el número de unidades de ejecución
      físicas disponibles en el sistema sobre el cual se esté ejecutando el servidor. Es posible inspeccionar 
      las características de este sistema servidor mediante la instrucción \texttt{getSystemInfo()}, como se ha descrito
      en el punto \ref{funciones}.

      La sintaxis de dicha función admite el uso tanto de una lista de cadenas de caracteres conteniendo las 
      instrucciones a ejecutar o bien un descriptor de fichero abierto para lectura, del cual se irán obteniendo
      las instrucciones a ejecutar. Mediante ejemplos se ilustra de forma más clara:

\begin{verbatim}
>>> resultados =runInParallel(["result= getPrime(123)", 
    "result = modExp(getRandomZ(123),getRandomZ(213),getRandomZ(212))", 
    "m = MR('[1.1 2.2; 3.3 4.4]'); result = m*m"], 
    2)
>>> resultados
[74176631947940771198570817318499880729, 
43467349588208854046417386840063472730388965574114680533023797, 
  [ 8.47000000000000000000 12.10000000000000000000 ; 
18.15000000000000000000 26.62000000000000000000  ]]
>>> for r in resultados:
...     print r
...     
74176631947940771198570817318499880729
43467349588208854046417386840063472730388965574114680533023797
[   8.47000000000000000000  12.10000000000000000000 ]
[  18.15000000000000000000  26.62000000000000000000 ]
\end{verbatim}
  
      En el ejemplo anterior se ilustran varios puntos:
      \begin{itemize}
        \item Si se desea devolver algún resultado, éste debe ser asignado a una variable llamada \emph{\texttt{result}}.
        \item Python ofrece dos tipos de entrecomillado: las comillas simples «'» y las comillas dobles «"». Esto
        resulta útil por ejemplo cuando, ya dentro de una cadena de caracteres, es necesario utilizar otra, como 
        al definir el contenido de la matriz. 
        \item Si en la cadena a ejecutar hay más de una sentencia, éstas se separarán mediante punto y coma.
        \item Además de la lista conteniendo las instrucciones a ejecutar, el segundo argumento es un entero, que 
        indica el número de hilos ejecutores a utilizar. Si el número de elementos de la lista es mayor que este
        número de hilos, los elementos se irán procesando según vayan quedando hilos ejecutores libres.
        El orden de ejecución no es predecible \textit{a priori}. Sin embargo, los resultados se devuelven en orden.
      \end{itemize}


        Véase a continuación otro ejemplo:
\begin{verbatim}
>>> toRun1 = open('thread1.py')
>>> toRun2 = open('thread2.py')
>>> res = runInParallel([toRun1, toRun2], 1)
>>> print res
[239330591551575086659334062177758785221, [ 8 8 ; 12 5  ]]
\end{verbatim}

El contenido de los ficheros \texttt{thread1.py} y \texttt{thread2.py} es el siguiente:
\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=\texttt{thread1.py}] 
result = getPrime(123)
\end{lstlisting}

\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=\texttt{thread2.py}] 
gf = GF(2,4)
m = MGFx("[12 34; 67 98]",gf=gf)
result = m.getInverse()
\end{lstlisting}


    \subsubsection{Mecanismo de perfilado}
    En el cliente se encuentran disponibles los mecanismos de conteo de tiempo e instrucciones de la biblioteca, siempre que ésta
    haya sido compilada con soporte de perfilado. Las funciones relacionadas con este mecanismo son:
    \begin{description}
       \item{\texttt{resetProf}} Pone a cero los contadores de instrucciones. 
       Normalmente invocada como instrucción precedente a la primera
       a considerar en la toma de datos.
        \item{\texttt{getProfRes}}: Devuelve una lista con los contadores de instrucciones para cada hilo. Nótese
        que en este contexto, «hilo» se refiere a hilos utilizados por la biblioteca, no a ejecuciones simultáneas de 
        instrucciones por parte del cliente (véase la sección \ref{runInParallel}).
       \item{\texttt{startProfClock}} Inicia la toma de tiempo.
       \item{\texttt{stopProfClock}}  Detiene la toma de tiempo y devuelve como resultado el tiempo transcurrido desde el
       comienzo de dicha toma.
    \end{description}

    Véase el siguiente ejemplo:

\begin{verbatim}
>>> resetProf()
>>> startProfClock()
>>> RSA.getKeyPair(128)
  ...
>>> stopProfClock()
1.3800000000000008
>>> getProfRes()
>>> import pprint
>>> pprint.pprint( getProfRes() )
[{'ADD': 564153,
  'ADDMUL': 392859,
  'ADDX': 98000,
  'DIV': 51481,
  'MNOB': 890,
  'MUL': 79246,
  'SHIFTL': 95592,
  'SHIFTLR': 7922,
  'SUB': 0,
  'SUBX': 67766}]
\end{verbatim}


       
       \subsubsection{Ejemplos} \label{mpplab:ejs}
\paragraph{$\pi$ de Euler} 

%TODO

\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=$\pi$ de Euler] 
from matplotlib.pylab import *
from Client import *

def piEuler(last, first=3, initialCount=1):
  assert(last >= first)
  numPrimes = initialCount
  if not (first & 0x1): #even
    first += 1
  for i in xrange(first,last,2):
    if isPrime(Z(i)):
      numPrimes += 1

  return numPrimes

t1 = arange(100,1001,100)
piEulerResList = []
piEulerResList.append( piEuler(t1[0]) )
for i in xrange(1,len(t1)):
  piEulerResList.append( 
      piEuler(first = t1[i-1]+1, 
        last = t1[i], 
        initialCount = piEulerResList[-1]) 
      )

xlabel(r"$n$")
ylabel(r"$\pi(n)$")
plot(t1, piEulerResList, 'ro-', label=r"True pi(n)")
plot(t1, t1/log(t1), 'bx-', label=r"n/log(n) approx.")
legend()
\end{lstlisting}

  \begin{figure}[h!]
    \centering
    \includegraphics[width=0.85\textwidth,keepaspectratio]{plotExResult} 
    \caption{Gráfica resultado de la ejecución del ejemplo $\pi$ de Euler}\label{fig:plotExResult}
  \end{figure}

\paragraph{RSA y paralelismo}
%TODO

\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=$\pi$ de Euler] 
from Client import *
def getKeyPair(keySize):
  " Returns the pair (public, private) keys"
  (p,q) = runInParallel(["result=getPrime(%d)" % keySize ]*2,
      2, 
      "Generating prime pair (p,q)")
  n = p*q
  phi = (p-1)*(q-1)
  while True:
    e = getRandomZLessThan(n)
    if str(gcd(e,phi)) == '1':
      break
  d = modInverse(e,phi)
  return ((e,n) , (d,n))

def cypher(key, msg):
  e = key[0]
  n = key[1]
  return modExp(msg,e,n)

def decypher(key, cyphertext):
  d = key[0]
  n = key[1]
  return modExp(cyphertext,d,n)
\end{lstlisting}


\paragraph{Generadores y $\pi$}
%TODO

\begin{lstlisting}[captionpos=b,basicstyle=\small,frame=shadowbox,rulesepcolor=\color{black},language=python,caption=$\pi$ de Euler] 
from Client import *

def pi_series():
  sum = R('0')
  i = R('1.0')
  j = R('1')
  four = R("4")
  two = R("2")
  minusOne = R("-1")
  while(1):
    sum += j/i
    yield four*sum
    i += two; j *= minusOne

def euler_accelerator(g):
  s0 = g.next() # Sn-1
  s1 = g.next() # Sn
  s2 = g.next() # Sn+1
  two = R("2")
  while 1:
    yield s2 - ((s2 - s1)*(s2-s1))/(s0 - two*s1 + s2)
    s0, s1, s2 = s1, s2, g.next()

def firstn(g, n):
  for i in range(n):
    yield g.next()
    
\end{lstlisting}




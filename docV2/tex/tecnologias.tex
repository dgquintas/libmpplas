% TECNOLOGÍAS UTILIZADAS
\chapter{Tecnologías utilizadas}\label{chap:tecnologias}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          I've come up with a set of rules that describe our reactions to technologies:\\
            1. Anything that is in the world when you're born is normal and ordinary and is 
            just a natural part of the way the world works.\\
            2. Anything that's invented between when you're fifteen and thirty-five is new 
            and exciting and revolutionary and you can probably get a career in it.\\
            3. Anything invented after you're thirty-five is against the natural order of things.
        }
        \begin{flushright}
          \textbf{\textemdash Douglas Adams, The Salmon of Doubt}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip



\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          Any sufficiently advanced technology is indistinguishable from magic.
        }
        \begin{flushright}
          \textbf{\textemdash Arthur C. Clarke, "Profiles of The Future" }
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%

\begin{figure}[h!]
\centering
\includegraphics[width=0.65\textwidth,keepaspectratio]{dilbert} 
\caption{La terminología puede a veces resultar confusa...}
\end{figure}

\section{OpenMP}
A la hora de seleccionar la tecnología que nos permitiera explotar el paralelismo de los sistemas
disponibles, nos encontramos básicamente con dos requisitos: el que ésta pudiera ser integrada con 
el lenguaje C++ y que estuviera orientada a sistemas de memoria compartida. Tales restricciones 
redujeron las opciones a dos, a saber: OpenMP y POSIX Threads. Ambas tecnologías en mayor o menor 
medida extendidas y probadas. Sin embargo ser orientan a extremos diferentes del espectro de desarrollo. 
Mientras que PThreads --forma habitual de nombrar POSIX Threads-- requiere que la identificación de tareas, 
su asignación a unidades de ejecución y la sincronización sean realizadas de forma explícita por el programador,
el API de OpenMP abstrae de estos detalles. Por supuesto, esto resta cierta flexibilidad, pero dada la inherente
complejidad de la programación paralela, esto es más una ventaja que un problema. Por añadidura, OpenMP se orienta
al cálculo científico, mientras que PThreads pertenece tiene un alcance mucho más general; lo cual una vez más
resulta mejor en teoría pero contraproducente en la práctica. De hecho, OpenMP suele depender de PThreads --al
menos en sistemas UNIX-- en su implimentación, la cual es dependiente del compilador. En cierto modo, OpenMP
otorga una mayor productividad al «llevar de la mano» al programador mediante su API basada en el 
modelo de programación \textit{fork/join} (\cite{openmpstandard}\footnote{sección 1.3, pág. 17}), el cual 
es de especial utilidad a la hora de abordar problemas basados en el manejo de estructuras de tipo vector;
o dicho de otra manera, datos que cuya forma más natural de ser procesados es iterativamente.
Dos características más de OpenMP que decantan definitivamente la balanza son las que \cite{parpatterns}\footnote{
apéndice A, pág. 253} denomina como \textit{equivalencia secuencial} y \textit{paralelismo secuencial}.
\begin{description}
\item[Equivalencia secuencial.] Se dice que un programa es \textit{secuencialmente equivalente} cuando 
sus resultados son los mismos\footnote{concepto de igualdad sujeto a cuestiones tales como la no asociatividad
en la práctica de operaciones en punto flotante}  independientemente de si se ejecutan sobre un solo hilo --secuencialmente--
o sobre varios. Tales programas resultan más fáciles de mantener y en la mayoria de los casos de entender --y por ende de 
desarrollar.
\item[Paralelismo incremental.] Se refiere al estilo de programación en el cual un programa evoluciona
desde una versión secuencial hasta una paralela. Progresivamente se van paralelizando ciertas porciones del método
secuencial, comenzando por aquellas más sencillas de paralelizar o cuyos beneficios al ejercutarse en paralelo serían mayores.
El paralelismo es añadido por tanto de forma \emph{incremental}. En cada etapa de este proceso, es posible verificar que
el método continúa siendo correcto, lo cual ayuda de forma inestimable durante el desarrollo, y proporciona garantías bastante
razonables de que el método paralelizado funcionará correctamente.
\end{description}
El concepto de paralelismo incremental viene como anillo al dedo a la hora de adaptar los métodos heredados de 
LibNumth.

Aunque OpenMP es una tecnología que abstrae de los detalles de implementación, es más que probable
que las implementaciones hoy disponibles se fundamenten en un enfoque SMP. Sin embargo, existen
diferencias fundamentales entre un sistema SMP y otro basado en lo denominado como \textit{Chip-scale
MultiProcessors}, CMP --tales como los sistemas multicore, tan extendidos últimamente. Por ejemplo (\cite{landscape}),
el ancho de banda disponible entre los núcleos dentro de un mismo encapsulado es mucho mayor que la 
disponible entre procesadores en un sistema SMP. De forma análoga, la latencia es mucho menor, hasta un orden 
de magnitud, en el primer caso que en el segundo. Esto implica que \emph{no} debe pensarse en un sistema
basado en CMP como un sistema SMP, pese a que esta es la situación actual en prácticamente todos los frentes. Las
diferentes características de los sistemas multicore brindan la oportunidad de desarrollar nuevos algoritmos que exploten
estas diferencias.

\section{Comprobaciones en tiempo de compilación}\label{tech:staticasserts}
%XXX: completar con una intro
  Siempre es mejor prevenir que curar, como reza el refranero. Por tanto, mejor que simplemente detectar el error
  cuando el programa ya se encuentra en ejecución --que no es poco, pero no deja de ser una «mala cura»--, la detección
  de condiciones que no deberían darse es más efectiva cuanto antes se realice. La detección en \emph{tiempo de compilación}
  es el ideal, ya que estas comprobaciones no acarrearían un incremento en tiempo de ejecución\footnote{el tiempo de compilado
  sí es posible --incluso probable-- que aumente. Sin embargo, la compilación es un proceso puntual, frente a un número de ejecuciones
  arbitrario} y se detectarían incluso antes de que el propio programa tomase cuerpo.

  Por otra parte, no es posible comprobar más que aquellas condiciones evaluables en tiempo de compilación. En otras palabras,
  datos de carácter \emph{constante} y \emph{estático}. En código esto se traduce en valores declarados como \texttt{const static}, 
  o bien constantes --que no dejan de ser asimismo un caso particular de estos.

 \subsection{Consideraciones generales}
  Un proceso de compilación se interrumpe si y sólo si el compilador se ve forzado a generar código para una expresión inválida. 
  Existen circunstancias en las cuales, incluso si la expresión a compilar es inválida, el proceso de compilación no se interrumpirá
  porque el proceso de compilado no se ve forzado en ese momento a generar instrucciones para tal sentencia inválida. El ejemplo más
  habitual es el uso de clases parametrizadas: en una clase de plantilla, sólo las funciones miembro que son utilizadas son 
  instanciadas para los tipos de la plantilla. Puede darse el caso, dependiendo del compilador, de que el código de estos métodos
  siquiera sea procesado por el compilador si no son utilizados.

  ¿Cómo forzar entonces que nuestras comprobaciones estáticas sean efectivamente evaluadas, siendo así efectivas?
  \cite{moreexceptional} responde a esta pregunta de la siguiente manera (en su discusión \texttt{C} es una clase arbitraria):
  \begin{quote}
    The solution is to put the code that enforces the requirement into a function
    that's sure to be instantiated. The first thing most people think of is to put
    it in the constructor, because of course it's impossible to use C without
    invoking its constructor somewhere, right? True enough, but there could be
    multiple constructors and then to be safe we'd have to put the
    requirement-enforcing code into every constructor. There's a much easier
    solution, namely: \emph{Put it in the destructor}. There's only one destructor, and
    it's equally impossible to use C without invoking its destructor, so \emph{that's the
    simplest place for the requirement-enforcing code to live.}
  \end{quote}

  Los énfasis han sido añadidos. Por tanto, todo mecanismo de comprobación estática en tiempo de compilación
  se emplazará \emph{en el destructor} de la clase en cuestión.
      
  \subsection{Requiriendo métodos de un tipo de plantilla}\label{interfazSobreTemplate}
  Lo expuesto en este punto está basado en gran medida en lo expuesto en 
    \cite{moreexceptional}, item 4. La idea es poder implementar una clase
    parametrizada sobre un tipo \texttt{T} tal que se pueda garantizar que este tipo \texttt{T}
    implemente un cierto interfaz. Pero ¿no realiza acaso esta comprobación el compilador
    sin necesidad de pasos adicionales? Sólo parcialmente.
    \cite{moreexceptional} lo expone de la siguiente forma (en su discusión, llama a la
    clase a desarrollar \texttt{C<T>}, y requiere que exista \texttt{T* T::Clone()}): 
  \begin{quote}
    It's obvious that if \texttt{C} just writes code that tries to invoke \texttt{T::Clone()}
    without parameters, then such code will fail to compile if there isn't a
    \texttt{T::Clone()} that can be called without parameters. But that's not enough to
    answer this question: Just trying to call \texttt{T::Clone()} without parameters would
    also succeed in calling a \texttt{Clone()} that has defaulted parameters and/or does
    not return a \texttt{T*}. The goal here is to specifically enforce that \texttt{T} provide a
    function that looks exactly like this: \texttt{T* T::Clone()}.
  \end{quote}

  \subsubsection{Aplicaciones}
  El poder garantizar la existencia de ciertos métodos --incluido el tipo de su valor retornado-- para un 
  tipo \texttt{T} parámetro de una plantilla tiene una aplicación inmediata en los mecanismos de categorización
  algebraica descritos en la sección \ref{categorizacionAlgebraica}: si un tipo aspira a poder considerarse
  como, por ejemplo, un grupo, habrá de contar entre otros con un método para el cálculo de la inversa de la 
  suma, que retorne exactamente un elemento también del grupo (composición interna).

  
  \subsection{Asertos estáticos}
  El concepto de \emph{aserto} como «comprobación de la certeza de algo» en el mundo de la programación
  se asocia habitualmente a comprobaciones \emph{en tiempo de ejecución}. Así, por ejemplo, en C/C++ existe el mecanismo
  estándar \texttt{assert(ex)}, que interrumpirá la \emph{ejecución} de un programa si su argumento \texttt{ex} se evalúa como falso.
  Aunque pudiera parecer que las restricciones anteriormente descritas para las comprobaciones en tiempo de compilación
  en general convierten en algo inútil el aserto estático, se expondrán en el punto \ref{aplicacionesStaticAssert} 
  escenarios en los cuales sí resulta útil.

  Previamente, se mostrará cómo se consigue este comportamiento, 
  que no forma parte de C++ de forma directa. Considérese la macro mostrada en el listado \ref{lst:staticassert}.

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Definición de STATIC\_ASSERT, label=lst:staticassert]
#define STATIC_ASSERT(ex) \
  do { typedef int ai[(ex) ? 1 : -1]; } while(0) 
\end{lstlisting}

  Al contrario que en el caso del estándar \texttt{assert(arg)}, no interesa devolver un valor booleano: si la expresión
  a comprobar es falsa, el proceso de compilación debe detenerse con un error. Si no lo es, continuar sin más. Idealmente,
  tampoco se generará código adicional debido a estos asertos estáticos.
  \texttt{STATIC\_ASSERT(ex)} se traduce mediante el preprocesador en una serie de sentencias un tanto particular:
  \begin{enumerate}
    \item Un bucle do-while que no itera ( \texttt{while(0)} nunca se evaluará como cierto ).\label{enum:while0}
    \item Una declaración de un alias de tipo mediante \texttt{typedef}. \label{enum:typedef}
    \item Dentro del punto anterior, una declaración de un vector estático de un tamaño $1$ ó $-1$ dependiendo
    de si \texttt{ex} resulta cierto o falso \emph{a ojos de C++}. \label{enum:elQuizStaticAssert}
  \end{enumerate}
  
  Previamente al análisis de esta construcción: cuando se pone énfasis en el valor de verdad \emph{a los ojos de C++},
  se quiere recordar al lector que, heredado del mundo de C, en C++ se evalúa como cierto todo valor distinto
  de $0$\footnote{C++ contribuyó con el tipo \texttt{bool} y sus dos valores \texttt{true} y \texttt{false} a clarificar este ámbito,
  pero siguen siendo válidos los viejos hábitos (y en este caso, necesarios)}.

  ¿Cumple con los requisitos anteriormente expuestos el código anterior? Considerando su requisito fundamental, 
  que interrumpa la compilación en función de \texttt{ex}. Esto se consigue aprovechando la definición de 
  vector estático por parte del estándar ANSI C (\cite{c}\footnote{sección A8.6.2, pág. 239}):
  \begin{quote}
  Si la expresión-constante está presente, debe ser de tipo entero, y con valor mayor que $0$.
  \end{quote}
  Por «expresión-constante» se refiere en ese contexto al tamaño que se asigna al vector estático en su 
  declaración. Así pues, por lo expuesto en el punto \ref{enum:elQuizStaticAssert}. de la enumeración precedente,
  si \texttt{ex} se evalúa como falso, se estaría declarando \texttt{ai} con tamaño $-1$\footnote{¿y por qué si la
  referencia del lenguaje cita $0$ como valor ya invalido, se utiliza $-1$? Debido a que, tal como indica \cite{imperfectc++},
  por alguna razón algunos compiladores, entre ellos GCC y el compilador de Intel, sí consideran válido un vector estático de tamaño
  cero. Esto incumple claramente el estándar ANSI C, pero afortunadamente siquiera estos compiladores admiten un tamaño negativo
  como dimensión de dicho vector}, algo que incumple la semántica de C, y por tanto, también de C++. Este incumplimiento resulta
  en una interrupción de la compilación.

  La razón de ser de los puntos \ref{enum:while0}, y \ref{enum:typedef} es la de no generar código pero a la vez
  ser expresiones que son evaluadas por el compilador. Lo primero se consigue a raíz de que en realidad no existe código
  «ejecutable», ninguna sentencia con efecto sobre el entorno. Cualquier compilador que realice optimización de código (esto 
  es, todos) omitirá incluir ninguna instrucción correspondiente a esta porción de código. Pero no antes de haberla evaluado:
  a raíz de que el bucle, al ser do-while, fuerza la entrada en su cuerpo al menos una vez. En este cuerpo, el \texttt{typedef}
  ha de evaluar el nuevo alias declarado: el vector estático en cuya dimensión reside el meollo de la cuestión.

  Véase \cite{imperfectc++}\footnote{sección 1.4.8, pág. 25} para un enfoque de este método en más en profundidad.

  \subsubsection{Aplicaciones}\label{aplicacionesStaticAssert}
  Sus usos principales son los mismos que se le darían al clásico \texttt{assert} en tiempo de compilación: comprobación
  de casos que nunca deberían llegar a darse. Por ejemplo, en álgebra abstracta se requiere que el anillo que conforma
  un cuerpo cumpla una serie de propiedades: ser un anillo de división y ser conmutativo para el producto. \emph{Nunca} debería
  tenerse un cuerpo incumpliendo estas propiedades. De intentar declarar un objeto tal, el compilador debería evitarlo. Pues bien,
el código mostrado en el listado \ref{lst:staticAssertAp1} nos lo garantiza.
\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Comprobación estática de las propiedades de un anillo, label=lst:staticAssertAp1]
~Field() {
(...)
  STATIC_ASSERT( T::divisionRing );
  STATIC_ASSERT( T::multCommutative );
(...)
}
\end{lstlisting}

Una aplicación alternativa es el forzar la evaluación de funciones estáticas, que normalmente contendrán otro tipo de 
comprobaciones en tiempo de compilación. Por ejemplo:

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Forzando evaluación de funciones estáticas, label=lst:staticAssertAp2]
  ~Group() {
    STATIC_ASSERT( ValidateRequirements() );
  }
(...)
private:
  static bool ValidateRequirements() {
    T (T::*getAddInverse)() const  = &(T::getAddInverse) ;
    const T& (*getAddIdentity)()  = &(T::getAddIdentity) ;
    const T& (*getGroupGenerator)()  = &(T::getGroupGenerator) ;
    return true;
  }
\end{lstlisting}

En este ejemplo --también de lo anteriormente expuesto en la sección \ref{interfazSobreTemplate}-- se requiere que \emph{el compilador}, 
evalúe las tres asignaciones del método estático \texttt{ValidateRequirements()}. Para esto, se invoca este método 
dentro del aserto estático, ya que por la propia naturaleza de éste, evaluará su contenido. Si \texttt{ValidateRequirements}
es superado con éxito, el \texttt{return true} que concluye \texttt{ValidateRequirements} evitará que se incumpla
la evaluación del aserto estático.
    

  \subsection{Vínculos de familia}
  El siguiente método para asegurarse que una clase dada hereda de otra se expone en 
  \cite{imperfectc++}\footnote{sección 1.2.1, pág. 5}. Su utilidad, una vez más, deriva del hecho de ser
  una comprobación \emph{en tiempo de compilación}. Su equivalente en tiempo de \emph{ejecución} sería 
  la comprobación de que \texttt{dynamic\_cast< *Base >( instanciaDeriv )} no devuelve un valor nulo. Aun así,
  esta variante requiere una \emph{instancia} del tipo derivado, y en cualquier caso, su dominio de aplicación es 
  totalmente diferente: compilación vs. ejecución.


  Ver un ejemplo de la utilización de este patrón ayudará a explicar el funcionamiento del mismo. Considérese
  el listado \ref{lst:musthavebaseEj}. 
  \lstset{escapeinside={(*@}{@*)}}
  \begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left, caption=Ejemplo de uso del patrón de verificación de paternidad, label=lst:musthavebaseEj]
Constraints::must_have_base<S, Ring<S> > dummy1; (*@\label{algparent:Ring}@*)
Constraints::must_have_base<S, MPPDataType > dummy2; (*@\label{algparent:MPPDataType}@*)
  \end{lstlisting}
  Este fragmento de código se corresponde a la clase \texttt{Polynomial<S>} (véanse las secciones \ref{tipos:polinomios} 
  y \ref{impl:polinomios} para una descripción de este tipo de dato y una pormenorización de sus detalles de 
  implementación, respectivamente). En sendas líneas se comprueba que el tipo de plantilla \texttt{S} 
  --que recordemos se corresponde al tipo de los coeficientes del polinomio-- «es un» anillo y un tipo de dato
  «de la biblioteca». \footnote{que el tipo \texttt{S} verifique las propiedades algebraicas de un anillo por el mero hecho de 
  heredar de la clase \texttt{Ring} lo aseguran los mecanismos de categorización algebraica expuestos en la
 sección \ref{categorizacionAlgebraica} --los cuales, recuérdese, se valen precisamente de mecanismos de comprobación
  en tiempo de compilación}.

  Por tanto, \texttt{must\_have\_base<TipoHijo, TipoBaseEsperado>} compilará sin problemas si efectivamente \texttt{TipoHijo} 
  hereda de \texttt{TipoBaseEsperado}. Esta relación de herencia no tiene que ser necesariamente padre-hijo: se aprecia
  en el siguiente listado de código que implementa este patrón:

  \begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left, caption=Verificación de paternidad en tiempo de compilación, label=lst:musthavebase]
template<typename D, typename B>
struct must_have_base{
  ~must_have_base(){
    void(*p)(D*, B*) = constraints;
  }
  private:
  static void constraints(D* pd, B* pb){
    pb = pd;  (*@\label{algmusthavebase:quiz}@*)
  }
}; 
  \end{lstlisting}

  En la línea \ref{algmusthavebase:quiz} se encuentra el meollo del método. Si es posible realizar una conversión desde un puntero 
  del tipo derivado --\texttt{pd}-- a un puntero del tipo base --\texttt{pb}-- sin ningún tipo de \textit{cast}, \texttt{pd} resultará 
  cumplir el «ser un» elemento del tipo base. Es por esto que incluso si la relacion tipo derivado-tipo base no es de herencia directa, 
  también funcionaría, al poder realizarse dicha asignación.

  
  \subsubsection{Aplicaciones}
  Su campo de aplicación fundamental son las clases parametrizadas en las cuales se desea comprobar que sus parámetros de tipo cumplen ciertas
  propiedades «familiares», tal como se ha visto para el caso del tipo de los coeficientes en polinomios. Otra de las aplicaciones dadas a
  este mecanismo en la biblioteca ha sido en la implementación del nuevo repositorio de funciones (véase sección \ref{nuevoRepdeFuncs}), para
  garantizar que todo método considerado por el mismo hereda de \texttt{AbstractMethod}. Esto ahorra sorpresas desagradables en tiempo
  de ejecución si se trata de insertar u obtener una instancia de un objeto arbitrario: si se tratase de hacer esto, gracias a este mecanismo, 
  siquiera se superaría la etapa de compilación.

\section{Programación orientada a aspectos (AOP)}


Esta tecnología ha sido utilizada para la implementación de los mecanismos de perfilado,
como se expone en la sección \ref{impl:aop}.



\section{\textit{Mix-ins}}
  \subsection{Singleton}\label{sec:singleton}
    El patrón \emph{singleton} se encuentra entre los más conocidos y ampliamente utilizados de los
    expuestos en el ya clásico \cite{gof}\footnote{pág. 127}. Allí se define como:


    Es decir, un objeto del cual a lo sumo debe existir una instancia a lo largo de la ejecución, y que
    simultáneamente dicha instancia sea accesible globalmente. 
    
    Su caracter global puede hacer saltar las alarmas --y con razón-- en base a lo expuesto en el punto
    \ref{sec:thread-safety} referente a estructuras susceptibles de ser compartidas por varios hilos. 
    De hecho, en \cite{singletonperils}, figuras en el mundo de C++ de la talla de Scott Meyers y Andrei Alexandrescu
    analizan cómo %TODO

    - en methodsfactory he tenido que meter un mutex recursivo, ya que p ej cosas como random requieren hacer
    un get a su vez a hash. 
    - ademas, esta tambien omp critical. o sea, que hay dos niveles de concurrencia contra
    los que estar prevenido: el que viene de una ejecucion concurrente (multithread, como el server xmlrpc),
    y la ejec paralela con openmp. 
    - como dice el paper del alexandrescu y tal, se cachea alli donde es posible (static methodsfactory& funcs)
    la instancia del methodsfactory. Este static no molesta, ya que aunque este compartida la instancia, los metodos
    del mismo estan protegidos por locks. 


  \cite{singletonperils}
\section{\textit{Autowiring}}\label{sec:autowiring}
%TODO
%http://static.springframework.org/spring/docs/2.5.x/reference/beans.html#beans-factory-autowire
%by type
o sea, lo que hacen getFunc y setFunc de methodsfactory.

\section{\textit{Mock/stub objects}}
El concepto de \textit{mock object}\footnote{podría traducirse como «objecto simulado», aunque incluso en la
  bibliografía en castellano se utiliza la expresión en inglés} se introduce como un patrón útil dentro de las
  baterías de pruebas
  basadas en \textit{test units}\footnote{tecnología también utilizada. Véase sección \ref{testunits}} en la referencia
  fundamental de este campo, \cite{testdrivendevelopment}\footnote{capítulo 27}.

  El lugar de la librería resulta ventajosa la utilización de estos objetos es en lo relacionado con las rutinas 
  ofrecidas por en entorno OpenMP. Sin embargo, estas rutinas  --descritas en \cite{openmpstandard}\footnote{capítulo 3, pág. 97}--
  no se encuentran disponibles si se compila la librería con un compilador que no soporte OpenMP o bien si dicho 
  soporte se encuentra desactivado\footnote{una de las razones para prescindir de OpenMP aun cuando el compilador
  lo soporte sería que el sistema no cuenta más que con una unidad de ejecución --CPU. En tal caso, el utilizar
  OpenMP no aportaría ventajas y sí el inconveniente de la sobrecarga que acarrea su uso.}. ¿Qué hacer entonces 
  en aquellas partes del código donde se depende de estas rutinas? La solución trivial sería, previamente a su uso,
  comprobar si el soporte para OpenMP está disponible. Sin embargo, el mantener un código tal resulta muy engorroso 
  y, desde un punto de vista estético, muy poco elegante. 

  El punto clave hacia una mejor solución solución estriba en darse cuenta de que es posible \emph{imitar} el comportamiento
  de dichas rutinas cuando o bien el sistema no las soporta o se encuentran desactivadas: su comportamiento
  se correspondería a la situación en la que OpenMP sí estuviera disponible y el máximo número de hilos disponibles en
  todo momento fuera uno. De esta manera, cuando OpenMP se encontrase disponible, las llamadas a estas rutinas se 
  ejecutarían de forma «nativa». En caso contrario, serían sus «imitadoras» las que serían ejecutadas. Todo ello de forma
  transparente para el código que recurriese a las mismas.

  Esta idea no es nueva. Incluso \cite{openmpstandard} en su apéndice B provee una base para la implementación de estas
  rutinas sustitutas.


\section{\textit{Test units}}\label{testunits}
 



% CAPITULO IMPLEMENTACION 

\chapter{Detalles de implementación}\label{chap:detallesImpl}

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          Se deben absorber los colores de la vida, pero nunca deben de
          recordarse sus detalles. Los detalles son siempre vulgares.
        }
        \begin{flushright}
          \textbf{\textemdash Oscar Wilde, El retrato de Dorian Gray}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{flushright}
  \begin{minipage}[t]{13cm}
    \begin{flushright}
      \begin{quote}
        \emph{
          Cuídate de aquel que no se molesta en los detalles.
        }
        \begin{flushright}
          \textbf{\textemdash William Feather}
        \end{flushright}
      \end{quote}
    \end{flushright}
  \end{minipage}
\end{flushright}

\bigskip

\begin{center}{\line(1,0){325}}\end{center}

%--------------------------------------------------------%
\section{Introducción}
 

\section{Elementos generados dinámicamente}
  \subsection{La clase \texttt{SystemInfo}}
    \subsubsection{Configuración de la compilación}
    \subsubsection{La clase \texttt{CpuInfo }}

  \subsection{Mecanismo de perfilado basado en AOP}\label{impl:aop}

    \subsubsection{Preprocesando con Python}

  \subsection{Cliente de MPPLab}
    \ref{boostrapping}


\section{Asegurando la coherencia algebraica}
%comprobaciones estáticas de carácter algebraico de parámetros de templates
%en la particularización de estructuras genericas


\section{El repositorio de funciones}\label{impl:nuevoRepdeFuncs}

\section{La CPU SIMD}
Descrita en la sección \ref{basico:cpusimd}, esta CPU virtual consigue trabajar
no sólo con sus operandos de forma intrínsecamente paralela sino también con
tres tipos diferentes de datos. Todo ello con una interfaz común que aísla 
al usuario de los entresijos de su funcionamiento. Sin embargo no se
consigue este comportamiento por arte de magia.

\subsection{El tipo \texttt{SIMDDigit}}\label{simddigit}
  Se cuenta con registros de $128$ bits, que pueden ser distribuidos
  de diferentes formas, en función del tamaño de los tipos básicos que 
  acomode. En la figura \ref{fig:packedfloat} se representan cuatro
  números en coma flotante de $32$ bits, emplazados dentro de uno de estos
  registros de $128$ bits. 
   \begin{figure}[h]
    \centering
    \includegraphics[width=0.85\textwidth,keepaspectratio]{packedfloat} 
    \caption{Ejemplo de SIMDDigit}\label{fig:packedfloat}
  \end{figure}

  Las otras dos opciones soportadas son: dos números en coma flotante de $64$ bits
  y ocho enteros con signo de $16$ bits.

  Para que la implementación de la CPU SIMD sea realmente genérica, ha de ser posible
  trabajar con estos registros de $128$ bits de forma abstracta, sin entrar en el tipo
  de dato básico que contienen. Es a raíz de esta necesidad que surge el concepto de 
  \texttt{SIMDDigit}. El siguiente listado muestra su declaración tal como se encuentra
  en la biblioteca:
\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Declaración de SIMDDigit]
template<typename T>
struct SIMDDigit {
  SIMDDigit() {}
  SIMDDigit( const SIMDDigit<T>& src )
    : data(src.data) {}

  typedef typename SIMDtoBasicTypes<T>::BasicType BasicType;

  inline SIMDDigit& operator+=(const SIMDDigit<T>& rhs);
  inline SIMDDigit& operator-=(const SIMDDigit<T>& rhs);
  inline SIMDDigit& operator*=(const SIMDDigit<T>& rhs);
  inline SIMDDigit& operator/=(const SIMDDigit<T>& rhs);

  inline SIMDDigit& operator=(const SIMDDigit<T>& rhs);

  inline SIMDDigit& pack(const BasicType* const src);
  inline BasicType* unpack(BasicType* const out) const;
  inline BasicType sum() const;

  inline short getSize() const;

  T data;
};
\end{lstlisting}

Mediante esta clase parametrizada se ocultan los detalles concretos para cada uno de las
tres variedades. Como puede apreciarse, soporta las operaciones aritméticas básicas así como 
la introducción y extracción de sus componentes desde vectores estáticos sobre los tipos básicos.
Estas operaciones dependen de los métodos de la CPU SIMD, que implementa las siguientes operaciones:

 \begin{description}
  \item[Add] Suma dos elementos de tipo \texttt{SIMDDigit}.
  \item[Sub] Sustrae dos elementos de tipo \texttt{SIMDDigit}.
  \item[Mul] Multiplica dos elementos de tipo \texttt{SIMDDigit}.
  \item[Div] Divide dos elementos de tipo \texttt{SIMDDigit}.
  \item[Sum] Suma «horizontalmente» los elementos básicos de un \texttt{SIMDDigit}.
  \item[Pack] Convierte desde un vector de tipos básicos a un \texttt{SIMDDigit}.
  \item[Unpack] Convierte desde un \texttt{SIMDDigit} a un vector de tipos básicos.
 \end{description}

 Nótese que cuando se opera con SIMDDigits, se asume que los operandos albergan
 el mismo tipo de datos básicos.
 De no ser así, el resultado que se obtenga es indefinido, ya que por cuestiones de rendimiento a 
 este nivel no se realizan este tipo de comprobaciones.


\subsection{El problema del alineamiento}
  A causa de como el subsistema de memoria maneja los datos a y desde la memoria principal,
  pasando por varios niveles de cachés, resulta siempre ventajoso desde el punto de vista del 
  rendimiento alinear los datos en \emph{direcciones de memoria múltiplo del tamaño del tipo 
  en cuestión} (véase \cite{intelOpt, agnerc++}\footnote{sección 3.6.3, pág. 3-47; sección 8.5, pág. 78 resp.}). 
  Esto es aún más 
  importante en el caso de datos SIMD, tal como indica \cite{intelOpt}\footnote{sección 4.4.2, pág. 4-18}:
  \begin{quote}
  For best performance, the Streaming SIMD Extensions and Streaming SIMD Extensions
  2 require their memory operands to be aligned to 16-byte boundaries.
  Unaligned data can cause significant performance penalties compared to aligned
  data.
  \end{quote}

  Pese a que esta cita se refiere a las instrucciones SSE2, es asimismo válido para cualquier 
  tipo de dato, incluso no SIMD. Tan solo cobra más importancia en estos últimos.

  Hasta aquí la teoría. ¿En qué se traduce esto desde un punto de vista práctico? En que se le ha
  de indicar al compilador \emph{cómo alinear} los datos. En el mundo del lenguaje C y sus 
  estructuras de datos de bajo nivel esto resulta relativamente sencillo. Sin embargo, si se desea
  aprovechar las ventajas que ofrece el uso de las bibliotecas STL en C++, el asunto se complica,
  aunque afortunadamente sigue siendo posible. La solución pasa por utilizar mecanismos un tanto 
  oscuros de los contenedores STL como son los \emph{\textit{allocators}}: los objetos encargados
  de reservar la memoria que estos contenedores utilizarán. Si se particularizan estos \textit{allocators} 
  para que tal memoria se alinee en función de nuestras necesidades, se habrá resuelto el problema.
  Las modificaciones realizadas se recogen en la clase \texttt{SSEAlloc}, dentro del fichero \texttt{kernelSIMD.h}. 
  No se reproducen aquí por brevedad.

  

\section{Suplantación de identidad}
- mock openmp


\section{El mundo de los $64$ bits}

%\section{El maestro compilador}
%- scons

\section{Implementación de tipos}
  \subsection{Categorización algebraica}\label{categorizacionAlgebraica}
  En la figura \ref{fig:categoriasAlgebraicas} se muestra la jerarquía de clases que
  modelan las categorías algebraicas consideradas, junto con sus métodos (estáticos) asociados.  
  \begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth,keepaspectratio]{categoriasAlgebraicas} 
    \caption{Categorías algebraicas}\label{fig:categoriasAlgebraicas}
  \end{figure}
  Cuando un tipo de dato de la biblioteca (es decir, un hijo de \texttt{MPPDataType}) se
  encasilla dentro de esta jerarquía, sobre dicho tipo (representado mediante el parámetro 
  de plantilla \texttt{T}) se realizan una serie de comprobaciones, diseñadas para verificar
  que efectivamente dicho tipo cumple las condiciones impuestas por la categoría 
  algebraica a la que aspira pertenecer. Esta serie de comprobaciones se realizan por medio
  de \emph{asertos}. Un ejemplo correspondiente a la categoría de grupo --\texttt{Group.h}-- se
  reproduce en el listado \ref{lst:ejAssertsGroup}

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=STATIC\_ASSERT, label=lst:ejAssertsGroup]
~Group() {
  STATIC_ASSERT( ValidateRequirements() );
}
(...)
static bool ValidateRequirements() {
  T (T::*getAddInverse)() const = &(T::getAddInverse) ;
  const T& (*getAddIdentity)() = &(T::getAddIdentity) ;
  const T& (*getGroupGenerator)() = &(T::getGroupGenerator) ;

  return true;
}
\end{lstlisting}

  Se aprecia como dentro del método estático \texttt{ValidateRequirements} se verifica que el tipo \texttt{T} 
  cumple con las propiedades requeridas para un grupo. Comprobaciones similares, descritas textualmente en
  la figura \ref{fig:categoriasAlgebraicas}, se realizan para los anillos --\texttt{Ring.h}-- y los cuerpos
  --\texttt{Field.h}.

  Los tipos de la biblioteca susceptibles de ser categorizados --más adelante se verá la utilidad de esto-- dentro
  de estas familias algebraicas simplemente han de heredar de la clase adecuada. Por ejemplo, los enteros módulo
  un primo representan un cuerpo. Se indica este hecho, en código, de la siguiente manera:

\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Inclusión de $\mathbb{Z}_p$ como cuerpo]
(...)
  class Z_p : public Z_n, public Field<Z_p> 
(...)
\end{lstlisting}

  La categoría algebraica a la que pertenecen los distintos tipos de la biblioteca se representa en la figura
  \ref{fig:categorizacionAlgebraica} mediante un código de colores: el color de fondo de cada recuadro de tipo
  se corresponde con el color de fondo de su categoría en la figura \ref{fig:categoriasAlgebraicas}.

  \begin{figure}[h]
    \centering
    \includegraphics[width=0.95\textwidth,keepaspectratio]{categorizacionAlgebraica} 
    \caption{Categorización algebraica}\label{fig:categorizacionAlgebraica}
  \end{figure}

  Las matrices no encajan dentro de ninguna categoría, ya que tan solo las matrices cuadradas son
  susceptibles de ser invertidas y por tanto aspirar a formar un anillo (su producto no es conmutativo, por lo que
  tampoco podrían ser un cuerpo). Crear un tipo \textit{ex profeso} para representar matrices cuadradas limitaría
  en exceso la flexibilidad del tipo matriz. En cualquier caso, la categorización algebraica resulta útil precisamente
  para las comprobaciones de los tipos de plantilla al utilizar polinomios y matrices; es decir, a la hora de definir
  el tipo de los coeficientes/elementos, respectivamente. Por tanto, no sería posible con la actual implementación
  definir estructuras tales como «polinomios sobre matrices». Sin embargo, sí es posible definir, por ejemplo,
  una «matriz de polinomios sobre los enteros» 

  \subsection{Reales} \label{impl:reales}
    La implementación del tipo \texttt{mpplas::R} representando números en $\mathbb{R}$ con una precisión
    arbitraria se describe en \cite{miproyecto}\footnote{sección 5.4, pág. 56}. Sobre esta base se ha 
    ampliado el abanico de operaciones disponibles.
    \subsubsection{Cálculo de la raiz cuadrada} \label{impl:sqrt}
      El método implementado se describe en la sección \ref{tipos:sqrt}. Se corresponde con un método iterativo
      con un orden de convergencia cuádruple ilustrado en la ecuacion \eqref{eq:sqrtFinal} de dicha sección, que
      por comodidad se reproduce de nuevo a continuación:

        \begin{equation}
        \left\{ 
          \begin{array}{l}
            h_n = 1 - Ax^2_n \\
            x_{n+1} = x_n + \frac{x_n}{16} \left(  8h_n + 6h^2_n +5h^3_n \right) \label{eq:sqrtFinalBis}
          \end{array} 
        \right.
        \end{equation}

      En general, la implementación de este tipo de métodos iterativos no esconde muchos secretos. Sin embargo
      hay algunos aspectos dignos de mención en esta implementación que reflejan algunas estretegias de optimización
      interesantes.

\lstset{escapeinside={(*@}{@*)}}
\begin{lstlisting}[captionpos=b,basicstyle=\footnotesize,frame=shadowbox,rulesepcolor=\color{black},language=C++,numbers=left,caption=Cálculo de la raiz cuadrada, label=lst:sqrt]
static const double precomps[] = { 1, 0.5, 0.375, 0.3125 };  (*@\label{algsqrt:staticconstini}@*)
static const std::vector<mpplas::R> coeffs( precomps, precomps+4);
static const mpplas::Rx P(coeffs); (*@\label{algsqrt:staticconstend}@*)

mpplas::R xn(1/sqrt(this->getSPApprox()));  (*@\label{algsqrt:x0}@*)
mpplas::R xn_1 = xn;
xn.square();
xn *= (*this);
xn.invertSign();
xn += mpplas::R::ONE;

while(true){
  xn = P.evaluate(xn);  (*@\label{algsqrt:eval}@*)
  xn *= xn_1;
  if( xn_1 == xn ) {  (*@\label{algsqrt:parada}@*)
    xn *= (*this);  (*@\label{algsqrt:ajuste}@*)
    break;
  }
  xn_1 = xn;
  
  //hn = 1-(*this)*(xn.square());
  xn.square();
  xn *= (*this);
  xn.invertSign();
  xn += mpplas::R::ONE;
} 
return xn;
\end{lstlisting}

   En los siguientes puntos, las líneas mencionadas se refieren siempre al listado \ref{alg:sqrt}.

      \paragraph{Reutilización de datos \texttt{static const}.}
      Una forma de explotación de las \textit{lookup-tables} (\cite{agnerc++}\footnote{sección 13.1, pág. 113}) es 
      (re)utilizar datos \texttt{static} y \texttt{const}. Estos son creados una única vez, durante la etapa
      de inicialización estática del programa --la cual es ejecutada incluso antes que la función \texttt{main}--, y
      no pueden ser modificados, por lo que no incurren en una violación de la \textit{thread-safety} (véase sección 
      \ref{sec:thread-safety}. Estas dos propiedades hacen que el compilador sea capaz de optimizar más agresivamente
      estos datos, con el consecuente incremento en rendimiento. En el caso que nos ocupa, las líneas
      \ref{algsqrt:staticconstini}--\ref{algsqrt:staticconstend} explotan esta técnica. La cadena de dependencias
      que se establece entre ellas no es problemática dado que todos los datos comparten el caracter \texttt{static const}.

      \paragraph{Cálculo de $x_0$.} En todo proceso iterativo es importante contar con un buen punto inicial $x_0$,
      en especial en el método de Newton y similares este punto $x_0$ determina la convergencia del método. La pregunta
      es, ¿cómo obtener una buena aproximación inicial para un real arbitrario? Sería ideal poder utilizar las rutinas
      nativas del sistema --en este caso la función estándar \texttt{sqrt} de la librería de C-- sobre una versión 
      truncada del real de la biblioteca en cuestión. El problema se translada pues a como el actual \texttt{mpplas::R} 
      en formato \texttt{double} nativo. Dado que se cuenta con una función para obtener una representación
      textual del real de la biblioteca, podría pensarse en utilizarla conjuntamente con la función estándard de C \texttt{atof}.
      Este enfoque resultaría muy poco eficiente, ya que dicha transformación textual a base $10$ es costosa y por 
      su propia construcción no es posible limitarla a solamente algunas de sus cifras más significativas. 

      La solución adoptada requiere de que cada instancia de \texttt{mpplas::R} mantenga un \texttt{double} asociado
      a sí misma, de tal forma que con cada operación sobre dicha instancia, se actualice también esta aproximación.
      Dado que las operaciones que modifican el dato no son numerosas, no supone ningún trastorno. Asimismo, el coste
      de estas operaciones sobre el tipo nativo es despreciable. El cálculo de $x_0$ dependerá ahora de la aplicación
      de las funciones nativas sobre la aproximación \texttt{double} de la instancia en cuestión. Se aprecia este uso 
      en la línea \ref{algsqrt:x0}.


      \paragraph{Evaluación del polinomio.} El polinomio contenido en la formulación de $x_{n+1}$ en la ecuación \eqref{eq:sqrtFinalBis},
      $x_n + \frac{x_n}{16} \left(  8h_n + 6h^2_n +5h^3_n \right)$ 
      resulta en $ x_n + x_n \left(  \frac{8}{16}h_n + \frac{6}{16}h^2_n + \frac{5}{16}h^3_n\right)$. En base 
      a que en la implementación es posible prescindir de $h_n$ como valor independiente, utilizando el propio $x_n$ temporalmente,
      es posible refinar aún más dicho polinomio: $x_n \left(1 + \frac{8}{16}x_n + \frac{6}{16}x^2_n + \frac{5}{16}x^3_n\right)$.
      Por tanto, se ha reducido el paso iterativo a la evaluación de un polinomio de grado $3$ y su producto por $x_n$
      (línea \ref{algsqrt:eval}).
      Resulta interesante concentrar el grueso del cálculo sobre la evaluación del polinomio ya que esta operación se
      encuentra implementada de forma paralela (véase \ref{tipos:evaluacionPoly}). 

      \paragraph{Condición de parada.}
        ¿Cuándo deterner el proceso iterativo? En el momento en el que se tuvieran tantos dígitos exactos como 
        interesase. Si no se cuenta con el valor correcto --ya que es éste precisamente el que se está calculando--, 
        ¿cómo saber cuándo se han obtenido dichos dígitos? En realidad, tales preguntas sólo son tales desde un punto
        de vista puramente teórico. Sin embargo en la práctica siempre se cuenta con un límite en la precisión de trabajo, 
        aunque dicho límite pueda ser fijado a un valor arbitrario. Por tanto, «tantos dígitos exactos como interesase»
        pasa a ser «tantos dígitos exactos como precisión se esté considerando». La si la iteración $i$-ésima ha producido
        un $x_n$ con tantos o más dígitos como la precisión considerada, no tiene sentido proceder con la iteración $(i+1)$-ésima.
        Se estará en esa situación cuando se cumpla la condición reflejada en la línea \ref{algsqrt:parada}: $x_n = x_{n-1}$.
  
  
      \subsubsection{Funciones trascendentes} \label{impl:trascendentes}

  \subsection{Enteros $\mathbb{Z}M_n$}\label{implZM_n}

  \subsection{Polinomios}\label{impl:polinomios}
%    totalmente genericos
    \subsubsection{Verificando el carácter de \texttt{S}}
%      tiene que ser como ser como mínimo anillo conmutativo con unidad. Verificaciones estáticas

%      El requerir que \texttt{S} sea un tipo de la biblioteca responde simplemente a que en la posterior
%      implementación de los métodos, se depende de las características comunes de los tipos de la biblioteca.

    \subsubsection{Aritmética sobre polinomios}
      \paragraph{Suma y resta}
      \paragraph{Producto}
      \paragraph{División}

      \paragraph{Operaciones dependientes de \texttt{S}}
        \subparagraph{División sobre un dominio de factorización única}
        \subparagraph{Máximo común divisor sobre un dominio de factorización única}

      \paragraph{Evaluación}

    \subsubsection{Especializaciones}
      \paragraph{\texttt{Zx}}
      \paragraph{\texttt{Rx}}
      \paragraph{\texttt{Z\_px}}

  \subsection{Cuerpos finitos}\label{impl:cuerposFinitos}
    \subsubsection{Elementos de un cuerpo finito}


  \subsection{Matrices}

    \subsubsection{Descomposición $LU$}\label{sec:lu}
    
    \subsubsection{Inversión}

    \subsubsection{Cálculo del determinante}\label{impl:determinante}
      El cálculo del determinante resulta trivial una vez que se ha triangularizado 
      la matriz cuyo determinante se desea obtener. Es trivial comprobar que el 
      determinante de una matriz triangular --superior o inferior-- es igual al producto
      de los elementos de su diagonal (véase la definición de determinante: \ref{def:determinante}).
      Asimismo, si se tiene en cuenta que $det(AB) = det(A) det(B)$ para $A,B \in \mathcal{M}_n$ 
      (véase \cite{algebraburgos}\footnote{sección 4.4, pág. 85}), si se cuenta con la descomposición
      $LU$ de la matriz, el cálculo de su determinante se reduce al producto de los elementos de la 
      matriz triangular superior $U$:
      \[
        A = P \times L \times U  \Rightarrow det(A)  = \underbrace{det(P)}_{\sgn{\sigma}} \underbrace{det(L)}_{1} det(U) 
      \]

      El signo de $det(P)$ depende de la signatura de la permutación $\sigma$ de filas realizadas durante la
      descomposición $LU$. Recuérdese que los elementos de la diagonal de $L$ son \emph{por construcción} 
      iguales a la unidad. Por tanto:

      \begin{equation}
        det(A) =  \pm det(U) = \sgn{\sigma} \prod_{i=1}^n U_{n,n} \label{eq:detA_detU}
      \end{equation}

      El cálculo del determinante se reduce por tanto a una operación
      de complejidad lineal en $n$, \emph{dada la descomposición de $A$}. Es decir, la eficiencia y posibilidad 
      de utilización de la ecuación \eqref{eq:detA_detU} en la práctica depende no sólo del coste de la 
      descomposición de $A$ sino también de la \emph{posibilidad} de realizarla. Como se ha visto en el punto 
      \ref{sec:lu}, es requisito la existencia de inversa para elementos arbitrarios del conjunto sobre el cual
      se encuentre definida la matriz. El caso que viene inmediatamente a la cabeza como ejemplo de \emph{no} 
      posibilidad de utilización es por tanto el de $\mathbb{Z}$, donde tan solo $1$ y $-1$ tienen inversa... algo
      que ciertamente no parece suficiente\footnote{salvo que alguien pretenda el calculo de la inversa de la matriz
      identidad. En cuyo caso el problema realmente sería de dicho alguien.}. Sin embargo, a la vista de la definición
      dada en \ref{def:determinante} por la ecuación \eqref{eq:determinante}, sí es posible calcular desde un punto
      de vista teórico el determinante de matrices sobre anillos, tal como $\mathbb{Z}$. Hace falta tan solo aplicar
      una estrategia que no conlleve divisiones --es decir, inversiones.

      \paragraph{Cálculo de determinante sin divisiones: Gauss-Bareiss} \label{impl:bareiss}
      \cite{bareiss2}
      \cite{bookbareiss}\footnote{sección 10.2}
      \cite{cohen}\footnote{algoritmo 2.2.6, pág. 52}
      
      \begin{algorithm}
        \caption{Algoritmo de Gauss-Bareiss}\label{alg:bareiss}
        \begin{algorithmic}[1]
          \Procedure{Gauss-Bareiss}{Matriz $M \in \mathcal{M}_{n \times n}$}
          \State $sign \gets 1$
          \For{$i \in \{0, \ldots, n-2\}$}
            \State $p \gets M_{i,i}$
            \If{$p = 0$}
              \If{$ \neg \mathrm{pivot(}$i$\mathrm{)} $} 
                \Statex \Comment{Si \textrm{pivot} es falso, no se ha podido pivotar}
                \State \textbf{Return} $0$ \Comment{Matriz singular}
              \EndIf
              \State $sign \gets -sign$ \Comment{Se ha permutado una fila}
              \State $p \gets M_{i,i}$ \Comment{$M_{i,i} \neq 0$}
            \EndIf
            \For{$j \in \{i+1,\ldots,n-1\}$}
              \For{$k \in \{i+1,\ldots,n-1\}$}
                \State $M_{j,k} \gets M_{j,k} * p - M_{j,i}*M_{i,k}$
                \If{ $i > 0$ }
                  \State $M_{j,k} \gets M_{j,k} / M_{i-1,i-1}$ \Comment{Esta división \emph{siempre} es exacta}
                \EndIf
              \EndFor %for k
            \EndFor %for j
          \EndFor %for i

          \State \textbf{Return } $sign * M_{n-1,n-1}$
          \EndProcedure
        \end{algorithmic}
      \end{algorithm}

      Éste es uno de los métodos paralelizados en la biblioteca. Para más detalles, véase la sección
      \ref{para:bareiss}.

    \subsubsection{Especializaciones}
      \paragraph{\texttt{MatrixZ}}
      \paragraph{\texttt{MatrixR}}
      \paragraph{\texttt{MatrixGFx}}


  \subsection{Vectores}
    \subsubsection{Un caso especial: vectores sobre SIMDDigits}


import time, sys, os, shutil

filesStr = """
    Dimensions.cpp
    BitChecker.cpp
    CPUInfo.cpp
    CRT.cpp
    Factor.cpp
    GF.cpp
    GFx.cpp
    MethodsFactory.cpp
    GCD.cpp
    Hash.cpp
    LCM.cpp
    MatrixGFx.cpp
    MatrixZ.cpp
    MatrixZ_n.cpp
    MatrixR.cpp
    VectorialCPU.cpp
    Potencia.cpp
    Primos.cpp
    Profiling.cpp
    ProfResults.cpp
    ProfResult.cpp
    Random.cpp
    R.cpp
    Range.cpp
    RedModular.cpp
    Rx.cpp
    Seedbank.cpp
    SimbolosLegendre.cpp
    SystemInfo.cpp
    Trascendentes.cpp
    Utils.cpp
    VectorFloat.cpp
    VectorDouble.cpp
    VectorInt.cpp
    VectorR.cpp
    VectorZ.cpp
    Z.cpp
    Z_n.cpp
    Z_p.cpp
    Z_px.cpp
    Zx.cpp
    ZM_n.cpp

    """


#############################################################
#                    SUPPORT FUNCTIONS                      #
#############################################################
def getNativelySupportedArchs():
  natArchs = ['generic']
  x86ArchMachines = ['i386', 'i486', 'i586', 'i686', 'x86_64']
  currentPlatformMachine = platform.machine()

  
  if currentPlatformMachine in x86ArchMachines:
    natArchs.append('x86')
    if currentPlatformMachine == 'x86_64':
      natArchs.append('x86_64')
  elif currentPlatformMachine == 'ppc':
    natArchs.append('ppc')

  return tuple(natArchs)


def manually_insert(inputPath,outputPath,conditions):
  import re
  from os.path import dirname,abspath
  from os import getcwd, chdir, remove
  from tempfile import mkstemp
  oldPWD = getcwd()
  chdir(dirname(abspath(inputPath)))
  input = open(inputPath,'r')
  output = open(outputPath, 'w')
  pragma_str = "#pragma __libmpplas_manual_include"
  for line in input.xreadlines():
    if line.strip()[:len(pragma_str)] == "#pragma __libmpplas_manual_include":
      no_condition = False
      cond_read = ""
      if len(line.split()) == 2: #no cond
        no_condition = True
      else:
        cond_read = line.split()[2]
      include_line = input.next()
      if cond_read in conditions or no_condition:
        m = re.match(r'#include "([a-zA-Z0-9\_\.]+)"', include_line.strip())
        file_to_include = m.group(1)
        #parse input file for possible substitutions as well
        tmpOutFile = mkstemp()[1]
        manually_insert( file_to_include, tmpOutFile, conditions)
        tmpOutFileDesc = open(tmpOutFile, 'r')
        output.write(tmpOutFileDesc.read())
        tmpOutFileDesc.close()
        remove( tmpOutFile )
    else:
      output.write(line)
  chdir(oldPWD)
  input.close()
  output.close()

def dumpConfigToCpp(env, outFilename):
  from datetime import datetime
  from socket import getfqdn
  out = open(outFilename,'w')
  txt = """
/*  Generated by SCons on %s
 *  the %s 
 *  for source revision #%d  */

namespace mpplas{
  namespace CompilationConfig {
    const int OPT_LEVEL = %d;
    const char* const TARGET_ARCH = "%s";
    const bool DEBUG_ENABLED = %s;
    const bool PROFILING_ENABLED = %s;
    const bool OPENMP_ENABLED =%s;
    const bool RELEASE_VERSION = %s;
    const int SOURCE_REVISION = %d;
    const char* const SIMD_KERNEL = "%s";
    const char* const COMPILER_CMD = 
      "%s";
    const char* const BUILD_DATE = __DATE__;
    const char* const BUILD_TIME = __TIME__;
  }
};
"""

  res = txt % \
       (getfqdn(), 
        datetime.now().ctime(),
        int(env['SVN_REV']),
        int(env['optLevel']), 
        env['arch'], 
        str(bool(env['enableDebug'])).lower(), 
        str(bool(env['enableAOPProf'])).lower(), 
        str(bool(env['enableOpenmp'])).lower(),
        str(bool(env['enableRelease'])).lower(),
        int(env['SVN_REV']),
        env['enableSIMD'],
        env.subst( env['SHCXXCOM'] )
        )

  out.write(res);
  out.close();  


def setBitLengthDependentParams(env, bits = 32):
  assert( bits in (32,64) )
  bitsStr = str(bits)
  env.Append(CPPDEFINES = [('ARCHBITS', bitsStr)])
  env.Append(CPPDEFINES = 'ARCH_' + env['arch'] )
  env['ARCHBITS'] = bitsStr
  env.Append(CCFLAGS = ' -m%d ' % bits)
  env.Append(LINKFLAGS = ' -m%d ' % bits)
  env.filesStr += ' CPUInfo_%s.cpp ' % env['arch']


def getSIMDPreferenceList():
  #from most preferred to least.
  return ('sse2', 'sse')

#######################################################

Import('env')


env.Append(CCFLAGS = ' -pipe ')
env.Append(CCFLAGS = ' -O' + env['optLevel'])

env.filesStr = filesStr
  

if env['enableRelease']:
  env.Append(CPPDEFINES = ['RELEASE','NDEBUG'])


if env['enableExtraOpt']: 
  if( env['CXX'][:3] == 'g++' ): #gcc
    env.Append(CCFLAGS = ' -ffast-math')  
    
  elif ( env['CXX'][:2] == 'ic' ): #intel c compiler
    pass

if env['enableDebug']:
  if( env['CXX'][:3] == 'g++' ): #gcc
    env.Append(CCFLAGS = ' -ggdb3')
    
  elif ( env['CXX'][:2] == 'ic' ): #intel c compiler
    env.Append(CCFLAGS = ' -g')


if env['enableWarnings']:
  env.Append(CCFLAGS = ' -Wall -W')
#options processing ends

def CheckSIMD(context):
  context.Message('Checking for SIMD instructions support... ')
  context.env['SupportedSIMD'] = []
  ret = context.TryRun(
    r"""
      #include <iostream>
      #include <string>

      int main(){
      std::string res("[");
      uint32_t eax, edx, ecx;
      eax = 1;
      asm ( "cpuid;"
        : "=d"(edx), "=c"(ecx)
        : "a"(eax)
        );
      if( edx & (1L << 23) ){ res += "\"mmx\"" ; }
      if( edx & (1L << 25) ){ res += ", \"sse\"" ; }
      if( edx & (1L << 26) ){ res += ", \"sse2\"" ;}
      if( ecx & (1L) ){ res += ", \"sse3\"" ; }
      if( ecx & (1L << 9) ){ res += ", \"ssse3\"" ; } 
      res += "]";
      std::cout << res ;
      return 0;
      }
    """, '.cpp')
  if ret[0]:
    context.env['SupportedSIMD'] = ret[1]
  context.Result(ret[1])
  return ret[0]

def SetSIMDAuto(context):
  context.Message('Automatically selecting SIMD tech. to use...')
  for simdTech in getSIMDPreferenceList():
    if simdTech in context.env['SupportedSIMD']:
      context.env.Append(CPPFLAGS=' -m%s ' % simdTech )
      context.env['enableSIMD'] = simdTech
      break
  else: # nosimd
    context.env['enableSIMD'] = 'nosimd'

  context.Result(context.env['enableSIMD'])
      

def CheckX86Arch(context):
  context.Message('Checking for x86 architecture ... ')
  ret = context.TryRun(
    r"""
      #include <iostream>

      int main(){
        uint32_t eax, edx;
        eax = 0x80000001;
        asm ( "cpuid;"
          : "=d"(edx)
          : "a"(eax)
          : "ebx", "ecx"
          );
        if( edx & (1L << 29) ){ 
          std::cout << "x86_64"; /* the CPU has x86-64 support */ 
        }
        else {
          std::cout << "x86";
        }

        return 0;
      }
    """, '.cpp')
  if ret[0]:
    context.env['arch'] = ret[1]
  context.Result(ret[1])
  return ret[0]



def CheckOpenMP(context):
  context.Message('Checking for OpenMP support... ')
  ret = context.TryRun( 
    """
      #include <omp.h>
      int main(){
        #ifdef _OPENMP
          return 0;
        #else
          return 1;
        #endif
      }
    """, '.cpp')
  context.Result(ret[0])
  return ret[0]

# configuring starts (only if we are not cleaning)
if env.GetOption('clean'):
  if os.path.exists(File(env['CONFIG_LOG']).abspath):
    os.remove(File(env['CONFIG_LOG']).abspath)
else:
  conf = Configure(env,log_file=env['CONFIG_LOG'],custom_tests = {
    'CheckOpenMP':CheckOpenMP , 
    'CheckSIMD':CheckSIMD, 
    'CheckX86Arch': CheckX86Arch,
    'SetSIMDAuto': SetSIMDAuto} )
  if not conf.CheckType('uint32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "uint32_t". Exiting...'
    Exit(1)

  if not conf.CheckType('int32_t', '#include <stdint.h>\n', 'C++'):
    print 'Could not find C99 type "int32_t". Exiting...'
    Exit(1)

  conf.CheckSIMD()
  if env['enableSIMD'] == 'auto':
    conf.SetSIMDAuto()
      
  env.Append(CPPDEFINES = 'USESIMD_' + env['enableSIMD'] )

  if env['enableOpenmp']:
    prevCPPFLAGS = env.get('CPPFLAGS', "")
    prevLIBS = env.get('LIBS',"")
    prevLINKFLAGS = env.get('LINKFLAGS', "")
    if( env['CXX'][:3] == 'g++' ): #gcc
      env.Append(CPPFLAGS=' -fopenmp ', LIBS='-lgomp')
      
    elif ( env['CXX'][:2] == 'ic' ): #intel c compiler
      env.Append(CPPFLAGS=' -openmp ', LINKFLAGS='-openmp')

    if not conf.CheckOpenMP():
      env.filesStr += ' omp_mock.cpp '
      env['CPPFLAGS'] = prevCPPFLAGS
      env['LIBS'] = prevLIBS
      env['LINKFLAGS'] = prevLINKFLAGS
      env['enableOpenmp'] = False
  else: # openmp not selected as an scons option
    env.filesStr += ' omp_mock.cpp '
 

  if env['arch'] == 'auto':
    #TODO: check for other archs
    conf.CheckX86Arch()

    if env['arch'][:6] == 'x86_64':
      setBitLengthDependentParams(env, bits = 64)

    elif env['arch'][:3] == 'x86':
      setBitLengthDependentParams(env, bits = 32)
    else: # ppc, etc...
      setBitLengthDependentParams(env, bits = 32)


  else: # env['arch'] is not 'auto'. ie, it has been manually defined
    setBitLengthDependentParams(env) #assumes 32 bits

    try:
      import platform

      if env['arch'] not in getNativelySupportedArchs():
        print "\nWARNING: the selected architecture (" + env['arch'] + ") is not natively supported by this system"
        for i in xrange(3):
          time.sleep(1)
          print '.',
          sys.stdout.flush()
        else:
          print ''

    except ImportError:
      print "Platform support checking not supported by the Python installed: " + sys.version


  env = conf.Finish()
  # configuring ends

kernelsDir = '#/src/sources/kernel/'
if env['enableAOPProf']:
  if not env.GetOption('clean'):
    from os import system
    from os import getcwd, chdir
    from os.path import join as pjoin
    oldCWD = getcwd()
    chdir(str(Dir(kernelsDir)))
    manually_insert( str( str(Dir(kernelsDir)) + '/kernel.h') , str(str(Dir(kernelsDir)) + '/aop/kernel.h'), ( env['arch'], env['enableSIMD'] ) )
    kernelsDir += 'aop/'
    Execute(Delete( './aop/out'))
    chdir(str(Dir(kernelsDir)))
    simdDefs = ""
    if env['enableSIMD'] == "sse2":
      simdDefs = "-D__SSE2__ -D__SSE__ -D__MMX__"
    elif env['enableSIMD'] == "sse":
      simdDefs = "-D__SSE__ -D__MMX__"
    AOPConfigFilename = 'puma.config'
    AGpp = pjoin( str(Dir('#/extra/aop')), 'ag++')
    ACpp = pjoin( str(Dir('#/extra/aop')), 'ac++')
    AOPConfigGenCommand = '%s -m%s --gen_config -o %s' % (AGpp, env['ARCHBITS'] , AOPConfigFilename )
    AOPCommand =  \
      "%s -DUSESIMD_nosimd %s -DARCH_%s -DARCHBITS=%s -p . -I %s --config %s -d ./out"  \
          % ( ACpp, simdDefs, env['arch'], env['ARCHBITS'], Dir('#/src/headers'), AOPConfigFilename )
    kernelsDir += 'out/'
    print AOPConfigGenCommand
    system(AOPConfigGenCommand)
    print AOPCommand
    system(AOPCommand)
    chdir(oldCWD)

env.Append( CPPPATH=[kernelsDir] )


#env.Append(CPPDEFINES = [('SVN_REV', env['SVN_REV'])])

dumpConfigToCpp(env,str(File('#/src/headers/CompilationConfig.h')))

files = Split(env.filesStr)
def print_cmd_line(s, target, source, env):
  sys.stdout.write("Building %s -> %s...\n" %
    (' and '.join([str(x) for x in source]),
    ' and '.join([str(x) for x in target])))
#env['PRINT_CMD_LINE_FUNC'] = print_cmd_line

lib = env.SharedLibrary('mpplas', files)
env.Default(lib)
Alias('lib', lib)
Alias('all', lib)
env.Install(env['INSTALL_DIR_LIB'], lib)
Alias('install',env['INSTALL_DIR_LIB'])
Alias('all', 'install')
env.Clean('all', '#/src/sources/kernel/aop/out/')
env.Clean('all', '#/src/sources/kernel/aop/kernel.h')

env.Append(LIBPATH = [Dir(env['INSTALL_DIR_LIB'])])
Export('env')

#if 'tests' in map(str, BUILD_TARGETS):
SConscript(dirs='tests')
